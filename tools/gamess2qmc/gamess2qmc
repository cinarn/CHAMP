#!/usr/bin/perl

####################################################################################
# GAMESS -> CHAMP interface                                                        #
# (c) Friedemann Schautz 2002-2003                                                 #
# with small modifications by John Lawson 2004-2005                                #
# and larger modifications by Julien Toulouse 2005-2006                            #
# All-electron calculation possibility added by J. Toulouse 2005                   #
# Analytic Slater basis set option (-S) added by J. Toulouse 2005                  #
#                                                                                  #
# Script to extract geometry, radial part of basis functions (on a grid), orbitals #
# and CSF coefs. from GAMESS output and to convert into format suitable for CHAMP. #
# Run with -h to get a summary of command-line options.                            #
# The CHAMP input can be generated in either Schautz-Filippi or in Umrigar format. #
#                                                                                  #
# Schautz-Filippi format:                                                          #
# To get first 9 orbitals:                                                         #
# HF run:  gamess2qmc -g -r -s -n 9 gamess_output                                  #
# CI run:  gamess2qmc -g -r -s -n 9 -t initial -d 0.1 -u gamess_output             #
# or to get used orbitals (in GUGA only):                                          #
# CI run:  gamess2qmc -g -r -s -u -t initial -d 0.1 -u gamess_output               #
# The 0.1 says keep determinants with a coef. of 0.1 and larger                    #
#                                                                                  #
# Umrigar format:                                                                  #
# To get first 9 orbitals:                                                         #
# HF run:  gamess2qmc -C -t rhf -n 9 gamess_output                                 #
# CI run:  gamess2qmc -C -F -t initial -n 9 -d 0.1 gamess_output                   #
# or to get used orbitals (in GUGA only):                                          #
# CI run:  gamess2qmc -C -F -t initial -u -d 0.1 gamess_output                     #
# The 0.1 says keep determinants with a coef. of 0.1 and larger                    #
# The -F generates a separate .csf file that contains the coefs of dets (in        #
# addition to the csf coefs.  The former can be used to figure out how many        #
# independent CSFs there really are in those cases where the molecule has a        #
# higher point group symmetry than d4h symmetry (the highest symmetry in GAMESS).  #
#                                                                                  #
# At present det_threshold_det2csf=10*$det_threshold in line 501.  Can be changed  #
#                                                                                  #
# If it fails to put dets with close coefs in the same csf, consider increasing    #
# value from 1.e-8 to say 1.e-7 in lines 1860 and 1863.                            #
####################################################################################
#$Revision: 1.12 $

# package for analyzing command line arguments
use Getopt::Std;
use sort 'stable'; # impose stable sort (i.e., preserve initial order if degeneracies)

#######################################################################
sub main{
#######################################################################
# main driver for all input and output
#######################################################################

    printf "========= GAMESS to CHAMP interface =========\n" if(! $quiet);

    initialize();
    get_options();

    read_from_gamess();

# ECP or all-electron calculation?
    if($ecp){
     print "This is a ECP calculation.\n";
     $print_lorb=0;
    }
    else{
     print "This is an all-electron calculation.\n";
     $print_lorb=1; #print second line in basis.* files
    }


    if($verbose) {test_print();}

    if($reverse_transfo){
	expand_shells();
	read_qmc_lcao();
	transform_back();
	print_gamess_vec();
	exit;
     }

    if($make_geometry_file) {print_geometry();}

    if($make_radial_grids) {basis_grid();}

    if($make_cyrus_file){

        if($make_det_file || $make_csf_file){
          if($detread && $gugaread){
            transform_det();
	    trial_det_csf();
          } else {
            printf "ci [%s] guga [%s]\n",$detread,$gugaread;
            die "GUGA and/or CI-info missing!";
          }
        }

#        if($make_csf_file) {print_csf_cyrus();}

        expand_shells();
        transform_lcao();

        if($analytic_basis) {process_slater_exponents();}

        print_cyrus_input();

        if($make_csf_file) {print_csf_cyrus();}

#        print_orb(); # JT

#        if($get_orbital_eigenvalues[$orbtype] == 1){
#         print_orbital_eigenvalues();
#        }

        exit;
    }  # end if($make_cyrus_file)


    if($make_det_file || $make_efpci_file || $make_csf_file){
	if($detread && $gugaread){
	    transform_det();
	    trial_det();
	} else {
	    printf "ci [%s] guga [%s]\n",$detread,$gugaread;
	    die "GUGA and/or CI-info missing!";
	}
    } # end if($make_det_file || $make_efpci_file || $make_csf_file)


    if($make_csf_file) {print_csf();}

    if($make_det_file) {print_determinants();}

    if($make_efpci_file) {print_efpci_data();}

    if($orbread != -1){
	expand_shells();
	transform_lcao();
	print_lcao();
	if($make_radial_grids){
	    print_qmc_bf_info();
	}
    } else {
        if  ($make_csf_file != 1){
	  print STDERR "Warning: no orbitals \n" if(! $quiet);
        }
    } # end if($orbread != -1)

}

####################################################################
sub initialize{
####################################################################
# global initialization
# NOTE: all settings below can be overridden using the
# -x command line option, just put the appropriate perl
# command(s) in a file and execute it with -x

# strings indicating different orbital sections in gamess output
# ***WARNING: the information in the next 3 arrays depends on the
# Version of GAMESS and keeps changing!
#####################################################################

@orb_start=('^\s*EIGENVECTORS\s*$', '^\s*INITIAL GUESS ORBITALS\s*$',
            '^\s*NATURAL ORBITALS IN ATOMIC ORBITAL BASIS\s*$',
            '^\s*MCSCF NATURAL ORBITALS\s*$',
            '^\s*MCSCF OPTIMIZED ORBITALS\s*');

@orb_stop=('END OF RO?HF CALCULATION',
           'END OF INITIAL ORBITAL SELECTION',
           'END OF DENSITY MATRIX CALCULATION',
	   '------------------------',
           'DONE WITH MCSCF ITERATIONS');

# number of extra lines from start string to first orbital block
@lineskip1=(2,2,2,2,2);

# number of extra lines from orbital eigenvalues (or occ numbers) to coefficients
#@lineskip2=(2,2,2,3,2);
@lineskip2=(1,1,1,1,1); #JT

# irrep  label within lineskip2 (0: don't try to fetch them)
#@irreplabel=(2,2,2,0,2);
@irreplabel=(1,1,1,0,1);  #JT

# get orbital eigenvalues (0: no, 1:yes)
@get_orbital_eigenvalues=(1,1,0,1,1); #JT

# get occupation numbers (0: no, 1:yes)
@get_orbital_occ_numbers=(0,0,1,0,0); #JT

# mapping names (for command line option) to position in above arrays
%orbid=( rhf => 0, initial => 1, cinat => 2, mnat => 3, mopt => 4 );

# names for print out
@orbnames=('RHF','INITIAL','NATURAL (CI)','NATURAL (MCSCF)','OPTIMZED (MCSCF)');

# symbols -> angular momentum
%angular=( S => 0, P => 1, D => 2, F => 3, G => 4);

# Shells order
@shells = ('S','P','D','F','G');

# expected order of primitives in qmc
@basorder= ('S','XX','XXXX','X','XXX','Y','YYY','Z','ZZZ','YY','XXYY','ZZ','XXZZ','XY','XXXY','XZ','XXXZ','YZ','XXYZ','YYX','XXY','XXZ','XYZ','ZZX','ZZY','YYZ','YYYY','YYYX','YYXZ','YYYZ','YYZZ','ZZXY','ZZZX','ZZZY','ZZZZ');

# sequence of flags in qmc input
@basorder2=('S','*','X','Y','Z','*','*','*','*','YY','ZZ','XY','XZ','YZ',
	    '*','*','*','*','*','*','*','*','*','*','*','*','*');
@basorder3=('S','X','Y','Z','YY','ZZ','XY','XZ','YZ',
            'YYX','XXY','XXZ','XYZ','ZZX','ZZY','YYZ',
            'YYYY','YYYX','YYXZ','YYYZ','YYZZ','ZZXY','ZZZX','ZZZY','ZZZZ',
            '*','*','*','*','*','*','*','*','*','*','*');

%map_prim=( 'XX' => 'S', 'XXX' => 'X', 'YYY' => 'Y', 'ZZZ' => 'Z', 'XXXX' => 'S', 'XXYY' => 'YY', 'XXZZ' => 'ZZ', 'XXXY' => 'XY', 'XXXZ' => 'XZ', 'XXYZ' => 'YZ');

# primitives in shells in gamess
@{$shell{S}}=('S');
@{$shell{P}}=('X','Y','Z');
@{$shell{L}}=('S','X','Y','Z');
@{$shell{D}}=('XX','YY','ZZ','XY','XZ','YZ');
@{$shell{F}}=('XXX','YYY','ZZZ','XXY','XXZ','YYX','YYZ','ZZX','ZZY','XYZ');
@{$shell{G}}=('XXXX','YYYY','ZZZZ','XXXY','XXXZ','YYYX','YYYZ','ZZZX','ZZZY','XXYY','XXZZ','YYZZ','XXYZ','YYXZ','ZZXY');

# Number of function type (S,P,D,F,G...)
$function_type_nb = 0;

# Numbers of 1s, 2s, 2p, etc basis functions for analytic Slater basis set
$n1s=0;
$n2s=0;
$n3s=0;
$n4s=0;
$n5s=0;
$n2p=0;
$n3p=0;
$n4p=0;
$n5p=0;
$n3d=0;
$n4d=0;
$n5d=0;
$n4f=0;
$n5f=0;
$n5g=0;

# ECP calculation
$ecp=0;

# default values for grid parameters
$gridtype=3;
$gridpoints=1600;
$gridarg=1.003;
$gridr0=7.0;

# format string (for one number) for grid print out
$gridformat="  %.12E";
# format string for lcao coefficients output
$lcao_format=" % .8E";

# some constants
$d3b4=0.75;
$pi=atan2(1,0)*2.0;
$pi4i=1.0/($pi**(1.0/4.0));
$d5b4=5.0/4.0;
$sq8b3=sqrt(8.0/3.0);
$d7b4=7.0/4.0;
$d9b4=9.0/4.0;
$sq16b15=sqrt(16.0/15.0);
$sq2b105=sqrt(2.0/105.0);
$d11b4=11.0/4.0;
$sq1b1155=sqrt(1.0/1155.0);

$lcao_cs=sqrt(5.0);
$lcao_cd=1.0/sqrt(3.0);

}

################################################################
sub get_options{
################################################################
# process command line options
################################################################

    $verbose=0;
    $quiet=0;
    my %options = ();

# in the string argument of getopts, each command line
# option is specified with its letter (g for -g etc)
# if the option takes an argument (like -d 0.1) it is
# folowed by a colon (:). After invoking getopts, the
# hash %options will contain the values.

#JT getopts("grqht:v:n:b:x:ld:w:uc:sej:ED", \%options);
    getopts("grqht:v:n:b:x:ld:f:w:uc:sej:ao:EDCNFSJ", \%options);   #JT

# shortcuts (which can be changed by individual options)
# e.g. '-D' is the same as '-d 0.9 -w 1 -t initial -u'
# but '-D -w 2' or '-w 2 -D' will both change the arg of
# w (the trial state index) to 2.
   if(exists $options{E}){
       $options{e}=1 if(! exists $options{e});
       $options{s}=1 if(! exists $options{s});
       $options{t}='initial' if(! exists $options{t});
       $options{j}=0 if(! exists $options{j});
   }
   if(exists $options{D}){
       $options{d}=0.9 if(! exists $options{d});
       $options{w}=1   if(! exists $options{w});
       $options{t}='initial' if(! exists $options{t});
       $options{u}=1  if(! exists $options{u});
   }

# process all 'atomic' options
    if(exists $options{h}){
	print_usage();
    }

    if(exists $options{v}){
	$verbose=$options{v};
    }

    if(exists $options{q}){
	$quiet=1;
	$verbose=0;
    }

    $orbtype=0;

    $make_geometry_file=0;
    $make_cyrus_file=0;
    $make_csf_file=0;
    $make_lcao_file=0;
    $make_radial_grids=0;
    $analytic_basis=0;   # JT
    $options_JT=0; #JT
    $no_jastrow=0; #JT

    if(exists $options{g}){
	$make_geometry_file=1;
    }

    if(exists $options{r}){
	$make_radial_grids=1;
    }

    if(exists $options{s}){
	$make_symmetry_file=1;
    }

    if(exists $options{t}){
	if(exists $orbid{$options{t}} ){
	    $orbtype=$orbid{$options{t}};
	    $make_lcao_file=1;
	} else {
	    printf "known types : %s\n",join(" ",keys(%orbid));
	    die "bad orbital type: $options{t}";
	}
    }


    # create input file in cyrus format - suppress printing claudias' files
    if(exists $options{C}){
	if(exists $orbid{$options{t}} ){
          $make_cyrus_file=1;
          $make_radial_grids=1;
        } else {
	    printf "\n Input Error: Must Specify Orbital Type with -t!\n";
	    print_usage();
        }
        if(!exists $options{d}){
	    printf "Assuming single determinant wavefunction\n";
            $ncsf=1;
        }
    }

    # create input file in new format
    if(exists $options{N}){
          $make_new_file=1;
    }

    # output CSFs to file
    if(exists $options{F}){
       $make_csf_file=1;
    }

# analytic basis option !JT
    if(exists $options{S}){
       print "Analytic Slater basis requested.\n";
       $analytic_basis=1;
       $make_radial_grids=0;
    }
    else{
     print "Assuming numerical basis request.\n";
    }

# Personal options for J. Toulouse
    if(exists $options{J}){
       $options_JT=1;
    }

# input with no Jastrow
    if(exists $options{a}){
       $no_jastrow=1;
    }


# how many orbitals ?
    $porb=0;
    if(exists $options{n}){
	$porb=$options{n};
    }

# omit unused orbitals?
    if(exists $options{u}){
	$omit_unused_orbitals = 1;
    } else {
	$omit_unused_orbitals = 0;
    }

# there should be exactly one file to process
    if( $#ARGV != 0){
	print_usage();
    }
    else {
   # setup file names
	$gamess_file=$ARGV[0];
	if( ! -f $gamess_file ){
	    die "Input file $gamess_file does not exist!\n";
	}
    }

# base name
    $i=rindex($gamess_file,'.');
    if($i>0){
	$old_basname=substr($gamess_file,0,$i);
    } else {
	$old_basname=$gamess_file;
    }

# new base name
    if(exists $options{b}){
	$basname=$options{b};
    } else {
	$basname=$old_basname;
    }

# input file names
    $dat_file      = $old_basname . '.' . 'dat';

# output file names
    $basis_file    = $basname . '.' . 'basis';
    $geometry_file = $basname . '.' . 'geometry';
    $lcao_file     = $basname . '.' . 'lcao';
    $det_file      = $basname . '.' . 'det';
    $bf_info_file  = $basname . '.' . 'bfinfo';
    $sym_info_file = $basname . '.' . 'sym';
    $efpci_file    = $basname . '.' . 'efpci';
    if($options_JT){
    $cyrus_input_file    = $basname . '_vmc.inp';
    }else{
    $cyrus_input_file    = $basname . '.' . 'i0';
    }
    $new_input_file    = $basname . '_vmc_new.inp';
    $csf_file    = $basname . '.' . 'csf';
    $orb_file    = $basname . '.' . 'orb'; # JT

# name of output file
    if(exists $options{o}){
     $cyrus_input_file = $options{o};
    }

# VEC file
    if(exists $options{l}){
	$reread_lcao=1;
    }else{
	$reread_lcao=0;
    };

# LCAO file for reverse transformation
    if(exists $options{c}){
	$qmc_lcao_file=$options{c};
	$new_vec_file=$qmc_lcao_file . '.vec';
         $reverse_transfo=1;
     } else {
         $reverse_transfo=0;
     }

# determinants, threshold for gamess2qmc
      if(exists $options{d}){
	  $make_det_file = 1;
	  $det_threshold = $options{d};
      } else {
	  $make_det_file=0;
	  $det_threshold=0;
          $selected_det=1;
      }

# determinants, threshold for det2csf
      if(exists $options{f}){
	  $det_threshold_det2csf = $options{f};
      } else {
 	  $det_threshold_det2csf=10*$det_threshold
      }

# state for trial wave function
    if(exists $options{w}){
	$trial_state=$options{w};
    } else {
	$trial_state=1;
    }

# output for CSF based efpci code
    if(exists $options{e}){
	$make_efpci_file=1;
	$all_states=1;
    }

# output format for CSF occupation patterns
# (0=heuristic / 1= CASE VECTOR )
    if(exists $options{j}){
	$case_vector_format=$options{j};
    }else{
	$case_vector_format=0;
    }

# source extended option file
# this file must contain valid perl statements, which can be used to
# overide settings .
# Everything specified above this point (e.g. file names) can be changed
# by putting it in the 'extended options' file
     if(exists $options{x}){
	 $opt_file=$options{x};
	 open(RCFILE,"< $opt_file") || die  "can not open option file $opt_file : $!\n";
	 print "sourcing option file  $opt_file \n" if(! $quiet);
	 while(<RCFILE>){
	     print ">> $_\n" if($verbose);
	     eval($_);
	     if($@){
		 printf("Error in at line $. \n");
		 die;
	     }
	 }
     }

# create input file in cyrus format - suppress printing claudias' files
# is some output specified ?

    if( (! $make_geometry_file )
	&& (! $make_radial_grids)
	&& (! $make_det_file )
	&& (! $make_lcao_file)
        && (! $reverse_transfo)
        && (! $make_cyrus_file)
        && (! $make_csf_file)
	&& (! $make_efpci_file)){
	 print "\n\n  No output specified !\n\n";
	 print_usage();
    }
}

################################################################
sub eat_lines{
################################################################
# eat n lines
    my $n= $_[0];
    for(my $i=0; $i<$n; $i++){
	<>;
    }
}

################################################################
sub read_from_gamess{
################################################################
# main loop for reading from gamess : look for strings
# identifying a section and call the appropriate routine
# <> reads from standard input, each <>; eats a line
################################################################

    $orbread=-1;
    $detread=0;
    $gugaread=0;

    print "Reading gamess output: " if(! $quiet);

  READ_LOOP: while(<>){

      if(/ISPHER\s*=\s*1/) {
	  $ispher=1;
      }

      if( /^\s*RUN TITLE\s*$/){
	  eat_lines(1);
	  $_= <>; chomp;
	  $run_title=$_;
	  next READ_LOOP;
      }

      if( /^ ATOM      ATOMIC                      COORDINATES/){
	  eat_lines(1);;
	  read_geometry();
	  next READ_LOOP;
      }

      if( /^\s*ECP POTENTIALS\s*/){
          $ecp = 1;
	  eat_lines(2);
	  read_zcore();
	  next READ_LOOP;
      }

      if(  /^\s*ATOMIC BASIS SET\s*$/ ){
	  eat_lines(3);
	  read_basis();
	  next READ_LOOP;
      }

      if( /FROZEN CORE ENERGY =\s*([-]?[0-9]+[.][0-9]+)\s*$/){
	  $core_energy=$1;
      }

      if( /^\s*THE NUCLEAR REPULSION ENERGY IS\s*([-]?[0-9]+[.][0-9]+)\s*$/){
	  $enuc=$1;
      }

      if( /^\s*THE ADJUSTED NUCLEAR REPULSION ENERGY=\s*([-]?[0-9]+[.][0-9]+)\s*$/){
	  $enuc_ecp=$1;
      }

      if( /^\s*TOTAL ENERGY =\s*([-]?[0-9]+[.][0-9]+)\s*$/){
	  $total_energy=$1;
      }

      if( ($orbread == -1) && ($_ =~ $orb_start[$orbtype] )){
	  eat_lines($lineskip1[$orbtype]);
	  read_orbitals($orb_stop[$orbtype]);
	  $orbread=$orbtype;
	  next READ_LOOP;
      }

      if(/^\s*TOTAL NUMBER OF MOS IN VARIATION SPACE=\s*([0-9]+)/){
	  $mos_left=$1;
	  printf STDERR "\n\nWarning: Number of MOS reduced to %d!\n\n",$mos_left if(! $quiet);
      }

      if(/^\s*GUGA DISTINCT ROW TABLE /){
	  if($make_det_file || $make_efpci_file || $make_csf_file){
	      read_guga();
	      $gugaread=1;
	  }
	  next READ_LOOP;
      }

      if( /^ STATE #\s+([0-9]+)\s+ENERGY =/ ){
	  $state=$1;
	  if( ($states_read+1) != $state){
	      if($state <= $states_read){
		  printf STDERR "Warning : re-reading state %d !\n",$state  if(! $quiet);
	      } else {
		  die "state index out of range : $states_read $state";
	      }
	  } else {
	      $states_read++;
	  }
	  chomp;
	  @w=split;
	  $state_energy[$state]=$w[-1];
	  if($make_det_file || $make_efpci_file || $make_csf_file){
	      if( $all_states || ($state  == $trial_state) ){
		  read_det();
		  $detread=1;
	      }
	  }
	  next READ_LOOP;
      }
    }

    if($reread_lcao){
	if($orbtype==1){
	    reread_vec();
	    print "orbitals re-read from data-file\n";
	} else {
	    print "Warning: unable to re-read orbital coefficients\n";
	}
    }

# JT beg: add check if orbitals have been read
#    print "orbread=$orbread\n";
    if($orbread==-1){
     print "\nERROR: orbitals not found.\n";
     exit;
    }
# JT end

    print "done\n" if(! $quiet);
}


##################################################################
sub read_geometry{
##################################################################

    print "geometry " if(! $quiet);

    %seen=();

# loop as long as we have 5 fields on the line
  READ_LOOP: while(1) {
      $_ = <>;  chomp;

# split line into fields according to white space
      @w = split;

      if( $#w == 4 ){
	  push @atom_symbols,$w[0];

# remember unique atoms
	  if( ! $seen{$w[0]} ){
	      $seen{$w[0]}=1;
	      push @atom_types,$w[0];
	  }

	  push @atom_charges,$w[1];
	  push @atom_x,$w[2];
	  push @atom_y,$w[3];
	  push @atom_z,$w[4];

      } else {
	  last READ_LOOP;
      }
  }


    for(my $i=0; $i<= $#atom_symbols; $i++){
	if( ! exists($zatom{$atom_symbols[$i]})) {
	    $zatom{$atom_symbols[$i]}=$atom_charges[$i];
	} else {
	    if( $zatom{$atom_symbols[$i]} != $atom_charges[$i] ){
		print STDERR "Warning : new charge for type ",$atom_symbols[$i]," : ", $atom_charges[$i],"\n" if(! $quiet);
	    }
	}
    }

}

###################################################################
sub read_zcore{
###################################################################

    print "ecp " if(! $quiet);

  READ_LOOP: while(1) {

      $_ = <>;  chomp;

      if($_ =~ /^\s*THE ECP RUN REMOVES/){
	  next READ_LOOP;
      }

      if( /^\sNUMBER OF ELECTRONS KEPT IN THE CALCULATION IS\s*=\s*([0-9]+)$/){
          $nelec=$1;
          next READ_LOOP;
      }

      if( /^\sNUMBER OF OCCUPIED ORBITALS \(ALPHA\) KEPT IS\s*=\s*([0-9]+)$/){
          $nalpha=$1;
          next READ_LOOP;
      }

      if( /^\sNUMBER OF OCCUPIED ORBITALS \(BETA \) KEPT IS\s*=\s*([0-9]+)$/){
          $nbeta=$1;
          next READ_LOOP;
      }

      if( /^\s*THE ADJUSTED NUCLEAR REPULSION ENERGY=\s*([-]?[0-9]+[.][0-9]+)\s*$/){
	  $enuc_ecp=$1;
          next READ_LOOP;
      }

      if($_ =~ /^\s*ECP ANGULAR INTS/){
	  last READ_LOOP;
      }

      if($_ =~ /^\s*PARAMETERS\s+FOR\s+"([^" ]*)\s*"\s+ON\s+ATOM\s+([0-9]+)\s+WITH\s+ZCORE\s+([0-9]+)\s+AND\s+LMAX\s+([0-9]+)\s+ARE\s*$/){

        if (! exists $zcore{$atom_symbols[$2-1]} ){

          $zcore{$atom_symbols[$2-1]}=$3;
          $lpotp1{$atom_symbols[$2-1]}=$4+1;

        } else {

          if( $zcore{$atom_symbols[$2-1]} != $3){
            print STDERR "Warning : ignoring new ZCORE for atom type ",$atom_symbols[$2-1],"\n" if(! $quiet);
          }

        }

      }

      if($_ =~ /^\s*PARAMETERS\s+FOR\s+"([^" ]*)\s*"\s+ON\s+ATOM\s+([0-9]+)\s+ARE\s+THE\s+SAME\s+AS\s+ATOM\s+([0-9]+)\s*$/){

        if (! exists $zcore{$atom_symbols[$2-1]} ){

	    $zcore{$atom_symbols[$2-1]}=$zcore{$atom_symbols[$3-1]};
	    $lpotp1{$atom_symbols[$2-1]}=$lpotp1{$atom_symbols[$3-1]};

        } else {

	    if( $zcore{$atom_symbols[$2-1]} != $zcore{$atom_symbols[$3-1]}){
		print STDERR "Warning : ignoring new ZCORE for atom type ",$atom_symbols[$2],"\n" if(! $quiet);

	    }

        }

      }

   }

    if($verbose){
	print "\n Atom Charges\n";
	foreach my $i (@atom_types){
	    printf "Atom type %s charge %f ",$i,$zatom{$i};
	    if( exists $zcore{$i} ){
		printf "core charge %d ",$zcore{$i};
	    }
	    printf "\n";
	}
    }

}

#################################################################
sub read_basis{
#################################################################

    $current_func=0;
     printf(" basis ") if(! $quiet);
    %seen=();
    $ignore=0;

  READ_LOOP: while(1) {
      $_ = <>;  chomp;
      @w = split;

### WAS: for use of spherical harmonics instead of cartesian ones
      if($_=~/THIS RUN/)
      {
	  next READ_LOOP;
      }
      if($_=~/THE NUMBER OF ORBITALS KEPT/)
      {
	  next READ_LOOP;
      }
####
      if($_=~/^\s*SHELL\s+TYPE\s+PRIMITIVE/){
	  if( $_=~/GAUSS-SLAT/ ){ 
	      $gauss_slater_functions = 1;
	  }
	  if( $_=~/SLATER/ ){ 
	      $slater_functions = 1;
	  }
	  next READ_LOOP;
      }
      if( /^\sTOTAL NUMBER OF BASIS SET SHELLS.*$/ ){
	  next READ_LOOP;
      }

      if( /^\sNUMBER OF CARTESIAN GAUSSIAN BASIS FUNCTIONS\s*=\s*([0-9]+)$/){
          $nbasis=$1;
          next READ_LOOP;
      }

      if( /^\sNUMBER OF ELECTRONS\s*=\s*([0-9]+)$/){
          $nelec=$1;
          eat_lines(2);
          next READ_LOOP;
      }

      if( /^\sNUMBER OF OCCUPIED ORBITALS \(ALPHA\)\s*=\s*([0-9]+)$/){
          $nalpha=$1;
          next READ_LOOP;
      }

      if( /^\sNUMBER OF OCCUPIED ORBITALS \(BETA \)\s*=\s*([0-9]+)$/){
          $nbeta=$1;
          next READ_LOOP;
      }

      if( /^\sTOTAL NUMBER OF ATOMS.*$/ ){
	  last READ_LOOP;
      }


      if( $#w==0 ){

# only one field : atom symbol

	  $symbol=$w[0];
#	  print "\n symbol: $symbol\n"; #JT

# basis my be printed more than once

	  if( $seen{$symbol} ){
	      $ignore=1;
	      if($verbose){
		  print "\n *** Ignoring multiple listing for type $symbol\n";
	      }
	  } else {
	      $ignore=0;
	      $seen{$symbol}=1;
	  }

      } elsif($#w>0){

	  if( $ignore == 1){
	      next READ_LOOP;
	  }

# more than one : new basis function

          $is_new_function = 0;

	  if($current_func != $w[0]){
#             Here for the first function of each contraction.
              $is_new_function = 1;
	      $current_func=$w[0];
              push @function_type_index,$current_func;
              push @function_type_symbol,$symbol;
	      push @{$functions{$symbol}},$current_func;
	  }

         $ftype[$current_func]=$w[1];

#        Gaussian or Slater basis set?
         process_basis_function_type($symbol);   #JT

#        if analytic basis requested, check is all functions are Slaters.
         if($analytic_basis and ! $is_slater_function){
          print "\nfunction type $ftype[$current_func] is not a Slater function.\n";
          print "For an analytic basis set, all functions must be Slaters.\n";
          exit;
         }

         if($is_new_function and ($slater_functions || $gauss_slater_functions)){

           $exponents_slater[$current_func]=$w[3];
	   push @{$exponents[$current_func]}, $w[4];
	   push @{$coeff[$current_func]}, $w[5];

         }

	 elsif($is_new_function) {
	      $exponents_slater[$current_func]=$w[3];
	      push @{$exponents[$current_func]}, $w[3];
	      push @{$coeff[$current_func]}, $w[4];
         }

	 elsif($slater_functions || $gauss_slater_functions){
	     push @{$exponents[$current_func]}, $w[3];
	     push @{$coeff[$current_func]}, $w[4];
         }
	  
         else{
	      $exponents_slater[$current_func]=0;
	      push @{$exponents[$current_func]}, $w[3];
	      push @{$coeff[$current_func]}, $w[4];
	      

	      if($w[1] eq "L"){
		  push @{$coeff_L[$current_func]}, $w[5];
	      }
	      
          }

      }
  }

           if($analytic_basis) {check_slater_functions_order();}
}

#################################################################
sub read_orbitals{
#################################################################

# initializations
    $no1 = -1;
    $no2 = -1;
    $end_tag=$_[0];
    $orbitals=0;
    @irrep_strings=();
    @orbital_eigenvalues=();
    @orbital_occ_numbers=();

#  ignore extra orbitals
    if(defined $mos_left){
	$last_orb=$mos_left-1;
    } else {
	$last_orb=undef;
    }

    printf (" orbitals  ") if(! $quiet);
    $end_ok=0;
    my $wiss=0;

# Loop over input
  READ_LOOP: while(<>) {
      chomp;

      ### trick for correct parsing  WAS
      if ($wiss==1){
	  @w = split; $atomsym=$w[1]; $atomsymspace="$atomsym"."  ";
	  #	  print "Replacing $atomsym with  $atomsymspace\n";
      }
      if ($wiss > 1 && !($_ =~  $end_tag)) {
	  $_=~s/$atomsym/$atomsymspace/;
      }
      $wiss++;
      ####


      @w = split;


      if( $_ =~  $end_tag ){
          $end_ok=1;
	  last READ_LOOP;
      }

# extra garbage
      if( $_ =~ /^\s*tryfop/){
	  next READ_LOOP;
      }
      if( $_ =~ /^\s*dumpev/){
	  next READ_LOOP;
      }

      if( $#w == -1 ){
# blank line : reset orbital indices
	  $no1=-1;
	  $no2=-1;
	  next READ_LOOP;
      }

      if( ($no1 == -1) && ($no2 == -1)){
# line following the blank line should contain orbital indices
# (we are ignoring indices, just count)
	  $no1=$orbitals;
	  $orbitals += ($#w+1);
	  $no2=$orbitals - 1 ;

#         get orbital eigenvalues
          if($get_orbital_eigenvalues[$orbtype] == 1){


#         skip empty line for MCSCF natural orbitals
          if($orbtype == 3){
           $_=<>;
          }

          $_=<>; chomp; @w=split;
#          print "@w\n";
          for($i=0; $i<=$#w; $i++){
		  if((! defined $last_orb) || ($no1+$i <= $last_orb)){
		      $orbital_eigenvalues[$no1+$i]=$w[$i];
#                      print "\n orbital=$no1+$i eigenvalue=$orbital_eigenvalues[$no1+$i]";
		  }
	      }



          } # end if get orbital eigenvalues

#         get occupation numbers
          if($get_orbital_occ_numbers[$orbtype] == 1){
          $_=<>; chomp; @w=split;
#          print "@w\n";
          for($i=0; $i<=$#w; $i++){
		  if((! defined $last_orb) || ($no1+$i <= $last_orb)){
		      $orbital_occ_numbers[$no1+$i]=$w[$i];
#                      print "\n orbital=$no1+$i occ number=$orbital_occ_numbers[$no1+$i]";
		  }
	      }



          } # end if get occupation numbers



	  if($irreplabel[$orbtype] == 0){
	      eat_lines($lineskip2[$orbtype]);
	  } else {
	      eat_lines($irreplabel[$orbtype]-1);
# get irrep labels
	      $_=<>; chomp; @w=split;
	      for($i=0; $i<=$#w; $i++){
		  if((! defined $last_orb) || ($no1+$i <= $last_orb)){
		      $irrep_strings[$no1+$i]=$w[$i];
		  }
	      }
	      eat_lines($lineskip2[$orbtype]-$irreplabel[$orbtype]);
	  }
	  next READ_LOOP;
      }


      if( $no1 == 0){
# if we are reading orbital number one, we also save the basis function labels
	  push @lcao_atomsym, $w[1];
	  push @lcao_atomidx, $w[2];
	  push @lcao_bflabel, $w[3];
      }
      $col=4;
      for ($i=$no1; $i <=$no2; $i++){
	  if(( ! defined $last_orb) || ($i <= $last_orb)){
	      push @{$lcao[$i]}, $w[$col];
	  }

	  $col++;
      }
  }

    if(defined $mos_left){
	if( $orbitals >= $mos_left){
	    $orbitals=$mos_left;
	}
    }

    if(! $end_ok ){
	die "End of Orbitals section not found\n";
    }

# JT: check for additional symmetry in orbitals
    check_for_symmetry_in_orbitals();

}

#################################################################
sub reread_vec{
#################################################################
    open(VECFILE,"< $dat_file") || die "can not open file $dat_file : $!\n";
    if(! $quiet){
	print "new coefficients from file $dat_file\n";
    }
    $vec_ok=0;
    @vv=();
  VECFILELOOP: while(<VECFILE>){
      chomp;
      if(/^\s*STARTING ORBITALS/){
	  $_=<VECFILE>; chomp;
	  if(/^\s*\$VEC\s*$/){
	      while(<VECFILE>){
		  chomp;
		  if(/^\s*\$END\s*$/){
		      $vec_ok=1;
		      last VECFILELOOP;
		  }else{
		      push @vv,$_;
		  }
	      }
	  }
      }
    }
    close(VECFILE);
    if($vec_ok){
	if( $verbose ){
	    print $#vv," lines in $dat_file\n";
	}
	read_vec(\@vv);
    } else {
	die "ERROR reading orbitals from data file (VEC)\n";
    }
}

#################################################################
sub read_vec{
#################################################################
    $vec_lines=$_[0];
    @tmplcao=();
    $norbit=0;
    $o=0;
# field lengths of first 3 fields
    @flen=(2,3,15);
# re-read lcao coefficients from 'VEC' data
    foreach my $st (@$vec_lines){
	chomp $st;
	$st =~ s/\s+$//;
	$ncol=(length($st)-$flen[0]-$flen[1])/$flen[2];
	$orb_tag=substr($st,0,$flen[0]);
	if($orb_tag != $o){
	    $o=$orb_tag;
	    $norbit++;
	    $orb=$norbit;
	}
	$count=substr($st,$flen[0],$flen[1]);
	@values=();
	for($i=1;$i<=$ncol;$i++){
	    push @values,substr($st,$flen[0]+$flen[1]+($i-1)*$flen[2],$flen[2]);
	}
	push  @{$tmplcao[$orb-1]}, @values;
    }
    if(! $quiet){
	print "Number of orbitals re-read from VEC : $norbit of $orbitals\n";
    }

    $nb=$#lcao_bflabel;
    if($norbit > $orbitals){
	printf "too many orbital coefficients: old %d new %d\n",$orbitals,$norbit;
	die "Error in read_vec";
    }
    for(my $i=0; $i<$norbit; $i++){
	$nb2=$#{$tmplcao[$i]};
	if($nb != $nb2){
	    printf "Orbital %d : Different number of basis functions : old %d new %d\n",$i+1,$nb+1,$nb2+1;
	    die "Error in read_vec";
	}
	for(my $j=0; $j<=$nb; $j++){
	    ${$lcao[$i]}[$j]=${tmplcao[$i]}[$j];
	}
    }
}


#################################################################
sub read_guga{
#################################################################
    printf (" guga  ") if(! $quiet);
    $guga_end=0;
    $read_again=0;

    while( ($read_again == 1) || ($_ = <>) ){
	$read_again=0;
	chomp;

	@w = split;
	if(/END OF -DRT- GENERATION/){
	    $guga_end=1;
	    last;
	}

        if(/^\s*SYMMETRIES\s+FOR\s+THE\s+([0-9]+)\s+CORE,\s+([0-9]+)\s+ACTIVE,\s+([0-9]+)\s+EXTERNAL\s+MO-S\s+ARE\s*$/){
	    $ncore=$1;
	    $nactive=$2;
	    $nexternal=$3;

	    for($i=0;$i<$nactive+$nexternal;$i++){
		$global_orb_order[$i]='0';
	    }

	}	

	if(/NUMBER OF ALPHA ELECTRONS =/){
	    $alpha=$w[5];
	    next;
	}

	if(/NUMBER OF  BETA ELECTRONS =/){
	    $beta=$w[5];
	    next;
	}

	if(/THE WAVEFUNCTION CONTAINS\s+([0-9]+)\s+WALKS/){
	    $csf=$1;
	    next;
	}

	if(/^\s*CASE\s+VECTOR\s*=\s*([0-9]+)\s*$/){
	    $case_vector_index=$1;
            # following line containes case vector
	    $l = <>; chomp($l);
	    if($l =~ /^\s*([1234]+)\s*$/){
		$case_vectors[$case_vector_index]=$1;
	    } else {
		if(! $quiet) {
		    print STDERR "case vector index $case_vector_index missing\n";
		}
	    }

	}

	if(/^\s*CSF\s+([0-9]+):/){

            # Current and following lines contain expansion of CSF in terms of determinants
	    $csf_read++;
	    print "CSF  $csf_read ( index $1 )\n" if $verbose;
	    $l=join ' ',@w[2 .. $#w];
	    @csf_orbitals_tmp=();
	    $first_line=1;

	    while( $l =~ /^\s*C\(\s*[0-9]+\)=\s*(-?[0-9]\.[0-9]+)\s*:\s*(((-?[0-9]+)\s*)+)$/){
		$detlist_dim++;
		printf "OCC : [%s]\n",$l  if $verbose;
		$coef=$1;
		printf "coef = %f\n",$coef if $verbose;
		$occ_pattern=$2;
		printf "pattern=[%s]\n",$occ_pattern if $verbose;
		
		@occ=();
		while($occ_pattern =~ /\s*(-?[0-9]+)/g){
		    push @occ,$1;
		}
		print "OCC ARRAY ", join("|",@occ),"\n" if($verbose);

                # separate orbitals into alpha and beta
		@alp_occ=();
		@bet_occ=();
		foreach $o (@occ){
		    if( $o =~ /-([0-9]+)/ ){
			$active_orbitals{$1}++;
			push  @bet_occ,$1;
			if($first_line == 1){
			    if( ! ($csf_orbitals_tmp[$#csf_orbitals_tmp] eq $1)){
				push @csf_orbitals_tmp, $1;
				# print "active - orb added [$1]\n";
			    }
			}
		    }else{
			$active_orbitals{$o}++;
			push  @alp_occ, $o;
			if($first_line == 1){
			    if( ! ($csf_orbitals_tmp[$#csf_orbitals_tmp] eq $o)){
				push @csf_orbitals_tmp, $o;
				# print "active + orb added [$o]\n";
			    }
			}

		    }
		}
	
                # put orbitals into canonical qmc order keeping track of interchanges
		$pm=0;
		@occ_ab =  @occ;
		$done=0;
		while(!$done){
		    $swaps=0;
		    for($k=0; $k<$#occ_ab; $k++){
			if(abs($occ_ab[$k]) > abs($occ_ab[$k+1])){
			    $h=$occ_ab[$k];
			    $occ_ab[$k]=$occ_ab[$k+1];
			    $occ_ab[$k+1]=$h;
			    $swaps++;
			} elsif(abs($occ_ab[$k]) == abs($occ_ab[$k+1])){
			    if($occ_ab[$k] < 0 ){
				$occ_ab[$k]= -$occ_ab[$k];
				$occ_ab[$k+1]= -$occ_ab[$k+1];
				$swaps++;
			    }
			}
		    }
		    if( $swaps == 0 ){
			$done=1;
		    } else {
			$pm+=$swaps;
		    }
		}
		$phase=(-1)**$pm;

		if($verbose){
		    print " -- sorted -- \n";
		    print "count = $pm phase = $phase\n";
		    foreach $r (@occ){
			if($r<0){
			    print "$r ";
			} else {
			    print " $r ";
			}
		    }
		    print "\n";
		    foreach $r (@occ_ab){
			if($r<0){
			    print "$r ";
			} else {
			    print " $r ";
			}
		    }
		    print "\n";
		}
		$op2= join ' ',@occ_ab;
		
                # check if determinant has appeared in previous CSF
		if(exists($determinant{$op2})){
		    $detnr=$determinant{$op2};
		} else {
		    $detref++;
		    $determinant{$op2}=$detref;
		    $detnr=$detref;
		    print "New Determinant ($detref) [$op2]\n" if $verbose;
		}

                # save CSF info including reordering phases
		$phase_factors[$detnr]=$phase;
		push @{$csf_list[$csf_read]},{ coef=>$coef, det=>$detnr};

                # find position of orbital in case vector
		if($first_line == 1){
		    $n=0;
		    @s=split(//,$case_vectors[$csf_read]);
		    for($i=0;$i<=$#s;$i++){
			if($s[$i] != 1){
			    if($global_orb_order[$i] eq '0'){
				$global_orb_order[$i]=$csf_orbitals_tmp[$n];
			    } elsif($global_orb_order[$i]!=$csf_orbitals_tmp[$n]){
				$global_orb_order[$i]='?';
			    }
			    $n++;
			}
		    }
		
		}

		
		$l = <>; chomp($l); $first_line=0;

# JT beg: add this part to skip possibly blank lines between defining determinant lines in CSFs
#                print "line = $l\n";              #JT
                if ($l eq ''){                     #JT
#                  print "skip empty line!\n";     #JT
                  $l = <>; chomp($l);              #JT
                };                                 #JT
#                print "line = $l\n";              #JT
# JT end

	    }
	    $_=$l;
	    $read_again=1;
	    next;
	}
    }
    $n_actorb=(scalar keys(%active_orbitals));
    if($verbose){
	printf "GUGA reading done\n";
	printf "Electrons: %d alpha %d beta, CSF: %d (read %d) \n",$alpha,$beta,$csf,$csf_read;
	printf "Determinants %d\n",$detref;
	printf "%d Active Orbitals : ",$n_actorb;
    }

    if($guga_end != 1){
	die "read_guga: DRT info seems to be incomplete!\n";
    }
}

#################################################################
sub read_det{
#################################################################
    printf "[$state] " if(! $quiet);
    for($i=1;$i<=$csf;$i++)
    {
	${$cicoef[$state]}[$i]=0;
    }
    <>; <>; <>; $done=0;
    do{
	$_=<>; chomp; @w=split;
	if( (scalar @w ) == 3){
	    ${$cicoef[$state]}[$w[0]]=$w[1];
	    # with many orbitals, occupation patterns can continue on
	    # the next line in GAMESS output
	    if(($plen=length($w[2])) < ($nactive+$nexternal)){
		do{
		    $_=<>; chomp; @w=split;
		    if($#w != 0){
			die "error on pattern continuation line";
		    }
		    $plen += length($w[0]);
		} until($plen==$nactive+$nexternal);
	    }
         } else {
	     $done=1;
	 }
      } until $done;
}

#################################################################
sub transform_det{
#################################################################

    if($n_actorb != ($nactive+$nexternal)){
	$ntmp=$nactive+$nexternal;
	print STDERR "\nWarning: wrong number of active orbitals ? (used: $n_actorb, specified: $ntmp)\n" if(! $quiet);
	print STDERR "(this warning occurs also if some active orbitals are not used because of symmetry)\n\n" if(! $quiet);
        $n_actorb=$nactive+$nexternal;
    }

    foreach $d (keys(%determinant)){

        # fill core orbitals
	$nea=0; $neb=0;
	for($i=1; $i<=$ncore; $i++){
	    $orb_occ[$i]='2';
	    $nea++; $neb++;
	}

	for($i=$ncore+1; $i<=$ncore+$n_actorb; $i++){
	    $orb_occ[$i]='0';
	}
	@op=split ' ',$d;

        #fill active space
	foreach $oo (@op){
	    $oa=abs($oo);
	    if($oo > 0){
		$orb_occ[$oa]='+';
		$nea++;
	    } else {
		if($orb_occ[$oa] eq '+'){
		    $orb_occ[$oa]='2';
		} else {
		    $orb_occ[$oa]='-';
		}
		$neb++;
	    }
	}
	
	if( ($nea != $alpha) || ($neb != $beta)){
	    die "wrong number of electrons in determinant [$d] : alpha=($nea,$alpha) beta=($neb,$beta)\n";
	}

	$occ_pm = join '',@orb_occ;
	$sorted_detlist[$determinant{$d}]=$occ_pm;
	printf "[%s] [%s] %d \n",$d, $occ_pm,$determinant{$d} if $verbose;
    }

    # qmc phase factors (ababab... -> aaa...bbb.. reordering)
    for( $i=1; $i<=$#sorted_detlist;$i++){
	$p_count=0;
	@ocsym=split '',$sorted_detlist[$i];
	for($j=0; $j<=$#ocsym; $j++){
	    if(($ocsym[$j] eq '-') || ($ocsym[$j] eq '2')){
		for($k=$j+1; $k<=$#ocsym; $k++){
		    if(($ocsym[$k] eq '+') || ($ocsym[$k] eq '2')){
			$p_count++;
		    }
		}
	    }
	}
	$qmc_phase[$i]=(-1.0)**($p_count);
    }
}

#################################################################
sub read_qmc_lcao{
#################################################################
# read qmc lcao format
#################################################################

    open(QMCLCAO,"< $qmc_lcao_file") || die "can not open LCAO-file $qmc_lcao_file : $!\n";
    @qmc_lcao_lines=();
    $f=0;
    while(<QMCLCAO>){
     if(/^\s*lcao/){
       $f=1; next;
      }
      if($f){
	if(/^\s*end/){
	   $f=0; next;
	}
	push @qmc_lcao_lines, $_;
      }

    }
}

#################################################################
sub transform_back{
#################################################################
# assuming that the @qmc_lcao_lines contains lcao coefficients
# which correspond to the current basis , translate them back
# (existing LCAO will be erased)
#################################################################

    @lcao=();
    $n=0;
    foreach my $l (@qmc_lcao_lines){
	@col=split(/\s+/,$l);
	if($col =~ /\s*/){ shift @col;}
	@t=();
# reorder coefficients
	$j=0;
	for(my $ia=0; $ia <= $#atom_symbols; $ia++){
	    foreach my $i (@basorder){
		for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
		    $pk=${$prim_index2{$i}}[$k];
	            if($lcao_atomidx[$pk] == ($ia+1)){
                      $t[$pk]= $col[$j++];
		    }
	        }
	    }
        }
# add line
	push @{$lcao[$n]},@t;

#    print "orbital $n (a): (",join(')(',@col),")\n";
#    print "orbital $n (b): (",join(')(',@t),")\n";

	$n++;
    }

    $orbitals=$n;

# translate d-function coefficients back from 5d,s to 6d
	 transform_lcao_back();
}

#################################################################
sub trial_det{
#################################################################

   %det_coeff=();
   $selected_det=0;
   for($i=1; $i<=$csf_read; $i++){
      $c=${$cicoef[$trial_state]}[$i];
      if(abs($c) >= $det_threshold){
        foreach $d (@{$csf_list[$i]}){
          if(exists $det_coeff{$$d{det}}){
	    $det_coeff{$$d{det}} += ($$d{coef} * $c);
          } else {
	    $det_coeff{$$d{det}}  = ($$d{coef} * $c);
	    $selected_det++;
	  }
        }
      }
   }

   %used_orbitals = ();
   foreach $d (keys %det_coeff){
     @ocsym=split '',$sorted_detlist[$d];
     for($j=0; $j<=$#ocsym; $j++){
	if( $ocsym[$j] ne '0'){
	    $used_orbitals{$j}=1;
	}
     }
   }

   $n=0;
   foreach $i (sort {$a <=> $b} keys %used_orbitals){
      $orb_index{$i}=$n++;
   }
}

#################################################################
sub trial_det_csf{
#################################################################

    %det_coeff=();
    $selected_det=0;
    $ncsf=0;

    for($i=1; $i<=$csf_read; $i++){
	$c=${$cicoef[$trial_state]}[$i];
        if(abs($c) >= $det_threshold){

            $ncsf++;
            $csf_trial[$ncsf]=$csf_list[$i];
            $csf_coef[$ncsf]=$c;
            $cnt=0;

	    foreach $d (@{$csf_list[$i]}){

		if(exists $det_coeff{$$d{det}}){
		    $det_coeff{$$d{det}} += ($$d{coef} * $c);
		} else {
		    $det_coeff{$$d{det}} = ($$d{coef} * $c);

		    $selected_det++;
                    #$kept_det[$selected_det]=$$d{det};
		}
                $cnt++;
	    }
            $csf_ndet[$ncsf]=$cnt;

	}
   }

   @sorted_keys = sort {abs($det_coeff{$b}) <=> abs($det_coeff{$a})} keys %det_coeff;
   $cnt=0;
   foreach $d (@sorted_keys){
      $cnt++;
      $kept_det[$cnt]=$d;
   }
   if ($cnt!=$selected_det) {
      die "selected determinants don't match in trial_det_csf";
   }

   %used_orbitals = ();
   foreach $d (keys %det_coeff){
    @ocsym=split '',$sorted_detlist[$d];
    for($j=0; $j<=$#ocsym; $j++){
	if( $ocsym[$j] ne '0'){
	    $used_orbitals{$j}=1;
	}
    }
   }

   $n=0;
   foreach $i (sort {$a <=> $b} keys %used_orbitals){
      $orb_index{$i}=$n++;
   }
}

#################################################################
sub print_determinants{
#################################################################
# print selected determinants of trial state
#################################################################

    open(DETFILE,"> $det_file") || die  "cant open file $det_file : $!";
    printf DETFILE "# Determinants from run %s \n", $run_title;
    printf DETFILE "# State %s  Threshold on CSF coefficients %s\n",$trial_state,$det_threshold;
    printf DETFILE "&electrons nelec %d nup %d\n", $alpha+$beta,$alpha;
    printf DETFILE "determinants %d\n",$selected_det;

    @sorted_keys = sort {abs($det_coeff{$b}) <=> abs($det_coeff{$a})} keys %det_coeff;
    foreach $d (@sorted_keys){
	printf DETFILE "%.8f ",$det_coeff{$d}*$phase_factors[$d]*$qmc_phase[$d];
    }
    printf DETFILE "\n";

    foreach $d (@sorted_keys){
	@ocsym=split '',$sorted_detlist[$d];
	for($j=0; $j<=$#ocsym; $j++){
	    if( ($ocsym[$j] eq '+') || ($ocsym[$j] eq '2')){
		if($omit_unused_orbitals){
		    printf DETFILE "%3d ",$orb_index{$j}+1;
		} else {
		    printf DETFILE "%3d ",$j+1;
		}
	    }
	}
	printf DETFILE  "    ";
	for($j=0; $j<=$#ocsym; $j++){
	    if( ($ocsym[$j] eq '-') || ($ocsym[$j] eq '2')){
		if($omit_unused_orbitals){
		    printf DETFILE "%3d ",$orb_index{$j}+1;
		} else {
		    printf DETFILE "%3d ",$j+1;
		}
	    }
	}
	printf DETFILE "\n";
    }
    printf DETFILE "end\n";

    close(DETFILE)
}

###############################################################
sub print_csf{
###############################################################

    printf "Writing CSF output to %s \n",$csf_file;
    open(CSFFILE,"> $csf_file") || die  "cant open file $csf_file : $!";

    $num_csf=0;
    for($i=1; $i<=$csf_read; $i++){
      $c=${$cicoef[$trial_state]}[$i];
      if(abs($c) >= $det_threshold){
         $num_csf++;
      }
    }
    printf CSFFILE "%d %d %d ncsf nalpha nbeta\n",$num_csf,$nalpha,$nbeta;

    for($i=1; $i<=$csf_read; $i++){

      $c=${$cicoef[$trial_state]}[$i];
      if(abs($c) >= $det_threshold){

        $ndet=0;
        foreach $d (@{$csf_list[$i]}){
          $ndet++;
        }
        printf CSFFILE "%d\n",$ndet;

        foreach $d (@{$csf_list[$i]}){
          printf CSFFILE "%.8f ",$$d{coef}*$phase_factors[$$d{det}]*$qmc_phase[$$d{det}];

          @ocsym=split '',$sorted_detlist[$$d{det}];

          # print alpha electrons
          for($j=0; $j<=$#ocsym; $j++){
            if(($ocsym[$j] eq '+') || ($ocsym[$j] eq '2')){
              if($omit_unused_orbitals){
                 printf CSFFILE "%3d ",$orb_index{$j}+1;
              } else {
                 printf CSFFILE "%3d ",$j+1;
              }
            }
          }
          printf CSFFILE "    ";

          # print beta electrons
          for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '-') || ($ocsym[$j] eq '2')){
               if($omit_unused_orbitals){
                  printf CSFFILE "%3d ",$orb_index{$j}+1;
               } else {
                  printf CSFFILE "%3d ",$j+1;
               }
            }
          }
          printf CSFFILE "\n";

        }
      }
    }

    close(CSFFILE);
}

###############################################################
sub print_csf_cyrus{
#
# Revised: J. Toulouse, 11 Oct 2005: add orbital eigenvalues and occ numbers
###############################################################

    printf "Writing CSF output to %s \n",$csf_file;
    open(CSFFILE,"> $csf_file") || die  "cant open file $csf_file : $!";

    # print unique determinants
#   printf CSFFILE "%d ndet\n",$selected_det;
    printf CSFFILE "guga \n";
    printf CSFFILE "0 iused_orbs \n";
#   printf CSFFILE ".005 .05 cutoff_g2q,cutoff_d2c\n";
    printf CSFFILE "%.4f %.4f cutoff_g2q,cutoff_d2c\n",$det_threshold,$det_threshold_det2csf;
#process lcao coeff
    my @final_lcao_coef=();
    foreach my $j (@orbital_indices){
	my @temp_lcao_coef=();
        for(my $ia=0; $ia <= $#atom_symbols; $ia++){
            foreach my $i (@basorder){
                for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
                    $pk=${$prim_index2{$i}}[$k];
                      if($lcao_atomidx[$pk] == ($ia+1)){
			  my $temp_lcao_coef=sprintf "% .8E", ${$lcao[$j]}[$pk];
			  push @temp_lcao_coef, $temp_lcao_coef;
                      }
               }
            }
        }
	push @final_lcao_coef, [@temp_lcao_coef];
    }

    my @which_basis_used=();
    my $reduced_nbasis=0;
    if ($ispher == 1) {
	print "Removing redundant basis functions\n";
	my $tolerance = 10e-06;
	for my $current_basis (0..$nbasis-1) {
	    $current_basis_used=0;
	    for my $current_orb (@orbital_indices) {
		$current_basis_used = 1 if abs(${$final_lcao_coef[$current_orb]}[$current_basis]) > $tolerance;
	    }
	    push @which_basis_used, $current_basis if $current_basis_used;
	}

	for my $current_orb (@orbital_indices) {
	    @{$final_lcao_coef[$current_orb]} = @{$final_lcao_coef[$current_orb]}[@which_basis_used]; 
	}
	$reduced_nbasis = @{$final_lcao_coef[0]};
    }
    push @{$final_lcao_coef[0]}, "((coef(ibasis,iorb),ibasis=1,nbasis),iorb=1,norb)";

    if ($ispher == 1) {
	printf CSFFILE "%d %d %d %d %d 1.d-7 ndet, nelec, nup, norb, nbasis, eps \n",$selected_det,$nalpha+$nbeta,$nalpha,$porb,$reduced_nbasis;
    }
    else {
	printf CSFFILE "%d %d %d %d %d 1.d-7 ndet, nelec, nup, norb, nbasis, eps \n",$selected_det,$nalpha+$nbeta,$nalpha,$porb,$nbasis;
    }

    # print determinantal coefficients
    for($i=1; $i<=$selected_det; $i++){
        $d=$kept_det[$i];
#	printf CSFFILE "%.8f ",$det_coeff{$d}*$phase_factors[$d]*$qmc_phase[$d];
	printf CSFFILE "%s ",$det_coeff{$d}*$phase_factors[$d]*$qmc_phase[$d];
    }
    printf CSFFILE " (det_coef(idet),idet=1,ndet)\n";

# orbital eigenvalues or occ numbers

    # print orbital eigenvalues
    if($get_orbital_eigenvalues[$orbtype] == 1){
#    printf CSFFILE "$porb norb \n";
     for($i=0; $i<$porb; $i++){
      printf CSFFILE "$orbital_eigenvalues[@orbital_indices[$i]] ";
     }
      printf CSFFILE "(eigenvalues(ieig),ieig=1,norb)\n";
     }

    # print occ numbers
    if($get_orbital_occ_numbers[$orbtype] == 1){
#    printf CSFFILE "$porb norb \n";
     for($i=0; $i<$porb; $i++){
      printf CSFFILE "$orbital_occ_numbers[@orbital_indices[$i]] ";
     }
      printf CSFFILE "(occupations(iocc),iocc=1,norb)\n";
     }

# print lcao coefs
    print CSFFILE " @{$_}\n" for @final_lcao_coef;

#     foreach my $j (@orbital_indices){

#         for(my $ia=0; $ia <= $#atom_symbols; $ia++){
#             foreach my $i (@basorder){
#                 for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
#                     $pk=${$prim_index2{$i}}[$k];
#                       if($lcao_atomidx[$pk] == ($ia+1)){
#                          printf CSFFILE $lcao_format, ${$lcao[$j]}[$pk];
#                       }
#                }
#             }
#         }
#         if ($j==0) {
#          printf  CSFFILE " ((coef(ibasis,iorb),ibasis=1,nbasis),iorb=1,norb)\n";
#         } else {
#          printf  CSFFILE "\n";
#         }
#    }


    for($i=1; $i<=$selected_det; $i++){
        printf CSFFILE "\n";

        @ocsym=split '',$sorted_detlist[$kept_det[$i]];
        for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '+') || ($ocsym[$j] eq '2')){
                if($omit_unused_orbitals){
                    printf CSFFILE "%3d ",$orb_index{$j}+1;
                } else {
                    printf CSFFILE "%3d ",$j+1;
                }
            }
        }
        printf CSFFILE  "    ";

        for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '-') || ($ocsym[$j] eq '2')){
                if($omit_unused_orbitals){
                    printf CSFFILE "%3d ",$orb_index{$j}+1;
                } else {
                    printf CSFFILE "%3d ",$j+1;
                }
            }
        }
#       printf CSFFILE "\n";
    }
    printf CSFFILE "(iworbd(j,idet),j=1,nelec)\n";

    # print csf_trial
    printf CSFFILE "%d ncsf\n",$ncsf;

    # print csf_coef
    for($i=1; $i<=$ncsf; $i++){
      printf CSFFILE "%s ",@csf_coef[$i]
    }
    printf CSFFILE " (csf_coef(icsf),icsf=1,ncsf)\n";

    # num dets in each csf
    for($i=1; $i<=$ncsf; $i++){
      printf CSFFILE "%d ",$csf_ndet[$i];
    }
    printf CSFFILE " (ndet_in_csf(icsf),icsf=1,ncsf)\n";

    # print csf
    for($i=1; $i<=$ncsf; $i++){

      # print dets
      foreach $d (@{$csf_trial[$i]}){
        $cdet=$$d{det};
        for($j=1; $j<=$selected_det; $j++){
          if ($kept_det[$j]==$cdet) {
             $kdet=$j;
          }
        }
        printf CSFFILE "%2d ",$kdet;
      }
      printf CSFFILE " (iwdet_in_csf(idet_in_csf,%d),idet_in_csf=1,ndet_in_csf(%d))\n",$i,$i;

      # print coefs
      foreach $d (@{$csf_trial[$i]}){
        printf CSFFILE "%s ",$$d{coef}*$phase_factors[$$d{det}]*$qmc_phase[$$d{det}];
      }
      printf CSFFILE " (cdet_csf(idet_in_csf,%d),idet_in_csf=1,ndet_in_csf(%d))\n",$i,$i;

    }


    close(CSFFILE);

}

###############################################################
sub csf_strings{
###############################################################
# find occupation pattern to label entire CSF
# this is a bit heuristic and might result in
# different CSF having the same label
###############################################################

  CSFLOOP: for($i=1; $i<=$csf_read; $i++){
      $csf_rep[$i]='';
      $fmmin=9999;
      $detfm=0;
    DETLOOP: foreach $d (@{$csf_list[$i]}){
	printf "? [%s]",$sorted_detlist[$$d{det}] if($verbose);
	$s=0;
	$fm=0;
	$count=0;
	foreach $t (split '',$sorted_detlist[$$d{det}]){
	    if($t eq '+'){
		$s++;
		if($fm == 0){ $count++ }
	    } elsif( $t eq '-'){
		$s--;
		$fm=$count;
	    }
	    printf " %d ",$s if $verbose;
	    if( $s <0 ){
		next DETLOOP;
	    }
	}
	if($s >= 0){
	    if($fm < $fmmin){
		$fmmin=$fm;
		$detfm=$$d{det};
	    }
	}
    }
      if($detfm > 0){
	  $csf_rep[$i]=$sorted_detlist[$detfm];
	  $csf_phase[$i]=$phase_factors[$detfm];
      } else {
	  die "Error in csf label search";
      }
  }
}



###############################################################
sub print_efpci_data{
###############################################################

    open(EFPCI,"> $efpci_file") || die "Can not open file  $efpci_file : $!\n";

    csf_strings();
# multiply phase factors
    for($i=1; $i<=$states_read; $i++){
	for($j=1; $j<=$csf_read; $j++){
	    ${$cicoef[$i]}[$j]*=$csf_phase[$j];
        }
    }

    for($i=1; $i<=$csf_read; $i++){
       foreach $d (@{$csf_list[$i]}){
          $$d{coef}*=($phase_factors[$$d{det}] / $csf_phase[$i]);
                  printf "Phase factor: csf  %d  det %d  factor %f %f\n",$i, $$d{det},
                          $phase_factors[$$d{det}],$csf_phase[$i] if $verbose;
      }
    }

    printf EFPCI "&ci alpha %d beta %d\n",$alpha,$beta;
    printf EFPCI "&ci det %d states %d\n",$detref,$states_read;
    printf EFPCI "&ci orbitals %d core %d external %d\n",$ncore+$n_actorb,$ncore,$nexternal;
    printf EFPCI "&ci casevectors %d\n",$case_vector_format;
    if(defined $core_energy){
	printf EFPCI "&ci ecore %f\n",$core_energy;
    }
    if(defined $enuc_ecp){
     printf EFPCI "&ci enuc %f\n",$enuc_ecp;
    } else {
	if(defined $enuc){
	    printf EFPCI "&ci enuc %f\n",$enuc;
	}
    }
    if($case_vector_format>0){
	$ncp=0;
	$bad_sequence=0;
	printf EFPCI "orbital_sequence %d\n",$nactive+$nexternal;
	for($i=0;$i<$nactive+$nexternal;$i++){
	    if($global_orb_order[$i] eq '?'){
		$bad_sequence++;
	    }
	printf EFPCI "%s ",$global_orb_order[$i];
	}
	printf EFPCI "\nend\n";
    } else {
	$ncp=1;
    }

    if($bad_sequence>0){
	print STDERR "Warning: orbital sequence could not be determined!\n" if(! $quiet);
	printf EFPCI "# Warning: orbital sequence could not be determined!\n";
	$case_vector_format = 2;
    }

    printf EFPCI "csf %d %d\n",$csf_read,$ncp;

    for($j=1; $j<=$csf_read; $j++) {
	if($case_vector_format == 0){
	    printf EFPCI "%s\n",$csf_rep[$j];
	}elsif($case_vector_format == 1){
	    $s=$case_vectors[$j];
	    $s =~ s/1/0/g;
	    $s =~ s/2/+/g;
	    $s =~ s/3/-/g;
	    $s =~ s/4/2/g;
	    printf EFPCI "%s\n",$s;
	}else{
	    printf EFPCI " (csf %d)\n",$j,
	}
    }
    print  EFPCI "end\n";

    printf EFPCI "determinants %d\n",$#sorted_detlist;
    for( $i=1; $i<=$#sorted_detlist;$i++){
	printf EFPCI "%s\n",$sorted_detlist[$i];
    }
    print  EFPCI "end\n";

    printf EFPCI "states %d\n",$states_read;
    for($i=1; $i<=$states_read; $i++){
	printf EFPCI "% f ",$state_energy[$i];
    }
    print EFPCI "\n";

    for($i=1; $i<=$states_read; $i++){
	for($j=1; $j<=$csf_read; $j++) {
	    printf EFPCI "%f ",${$cicoef[$i]}[$j];
        }
        print  EFPCI "\n";
    }
    print  EFPCI "end\n";
    print  EFPCI "csfmap\n";
    printf EFPCI "%d %d %d\n",$csf_read,$#sorted_detlist,$detlist_dim;
    for($i=1; $i<=$csf_read; $i++){
      printf EFPCI "%d\n",$#{$csf_list[$i]}+1;
        foreach $d (@{$csf_list[$i]}){
          printf EFPCI "%d  % f\n",$$d{det},$$d{coef};
        }
    }
    print EFPCI "end\n";
    close(EFPCI);
}

###############################################################
sub test_print{
###############################################################

    printf "atom types %s\n", join(" ",@atom_types);

    print " coordinates\n";
    for($i=0; $i <= $#atom_symbols; $i++){
	printf "%d : %s %d % f % f % f \n", $i,$atom_symbols[$i],$atom_charges[$i],
          $atom_x[$i],$atom_y[$i],$atom_z[$i];
    }


    print " basis\n";
    foreach $i (keys %functions){
	printf "symbol %s \n ",$i;
	foreach $j (@{$functions{$i}}){
	    printf "function %d type %s exp ",$j,$ftype[$j];
	    foreach $e (@{$exponents[$j]}){
		printf "%f ",$e;
	    }
	    printf "\n";
	}
	printf "\n";
    }
    if($orbread == -1){
	print "no orbitals of type $orbtype found !!\n";
    } else {
	printf " orbitals: type %d number %d\n", $orbtype,$orbitals;
	if($verbose > 2){
	printf "sym   %s\n", join " ",@lcao_atomsym;
	printf "index %s\n", join " ",@lcao_atomidx;
	printf "label %s\n", join " ",@lcao_bflabel;
	if($verbose > 3 ){
	    for($i=1; $i<=$orbitals;$i++){
		printf " %s \n",join " ",@{$lcao[$i]};
	    }
	}
	}
    }
}

###############################################################
sub basis_grid{
###############################################################

    if( ! $make_radial_grids ){
	$gridpoints=2;
    }
    $gridr0_save=$gridr0;
    if($gridtype == 3) {
	$gridr0=$gridr0/($gridarg**($gridpoints-1)-1);
    }
# put radial parts of basis functions on grids
    $c = 0;
    $radial_ptr=1;
# radial part index for primitives
    %prim_radial=();
    foreach my $i (@atom_types){
	@bgrid=();
	$c++;
	compute_grid(\@bgrid);
	@lbas=();
	foreach my $j (@{$functions{$i}}){
	    print "BASIS GRID atom type $i function $j type  $ftype[$j]\n" if($verbose);
	    if($ftype[$j] eq 'L'){
		add_function('S',\@{$exponents[$j]},\@{$coeff[$j]},\@bgrid);
		add_function('P',\@{$exponents[$j]},\@{$coeff_L[$j]},\@bgrid);
	    } else {
		add_function($ftype[$j],\@{$exponents[$j]},\@{$coeff[$j]},\@bgrid);
	    }
	}
	$prim_radial{$i}=$radial_ptr;
	$radial_ptr+=$#{$bgrid[0]};
	if($make_radial_grids){
	    $file="$basis_file.$i.$c";
	    open(GRIDFILE,"> $file") || die "cant open file $file : $!";
	    printf GRIDFILE "%d %d %d %f %f 0   nrbas,igrid,nr,exp_h_bas,r0_bas,icusp\n",$#{$bgrid[0]},$gridtype,$gridpoints,$gridarg,$gridr0_save;
	    printf GRIDFILE "%s\n",join(" ",@lbas) if($print_lorb);
	    for(my $k=0; $k<=$#bgrid; $k++){
		printf GRIDFILE "%s\n", join("",map(sprintf($gridformat,$_),@{$bgrid[$k]}));
	    }
	    close(GRIDFILE);
	    printf("Grid for atom type %s written to file %s\n",$i,$file)  if(! $quiet);
	}
    }
}

###############################################################
sub compute_grid{
###############################################################
# compute r values  according to grid type
###############################################################

    $grid=@_[0];
     for(my $k=0; $k<$gridpoints; $k++){
	if($gridtype == 1){
	    $r=$gridr0 + $gridarg*$k;
	} elsif($gridtype == 2){
	    $r=$gridr0 * $gridarg**$k;
	} elsif($gridtype == 3){
	    $r=$gridr0 * $gridarg**$k - $gridr0;
	}
	push @{$$grid[$k]}, $r;
    }
}

###############################################################
sub add_function{
###############################################################
# put a new function on the grid
###############################################################

    ($type,$ex,$co,$grid)=@_;
    print "add function $type $#$grid \n" if($verbose);
    $l=$angular{$type};
    push @lbas, $l;
    for(my $k=0; $k<=$#$grid; $k++){
	$r=${$$grid[$k]}[0];
	$r2=$r**2;
	$value=0;
        for($ib=0; $ib<=$#$ex; $ib++){
	    $z = gnorm($$ex[$ib],$l) * $$co[$ib]
		* exp(-1.0 * $$ex[$ib] * $r2);
	    $value += $z;
	}
        if( $l == 1){
	    $value *= $r;
	}
        elsif( $l == 2){
	    $value *= $r2;
	}
	elsif( $l == 3){
	
	    $value *= ($r2*$r);
#            print "r= ", $r, " value= ", $value, " l=3 \n"
	}
	elsif ($l == 4 )
	{
	    $value *= ($r2*$r2);
#            print "r= ", $r, " value= ", $value, " l=4 \n"
	}
        elsif ($l > 4 )
        {
          print "l must be less than or equal to 4.\n";
          exit;
        }
        if( abs($value) > 1.0E-15 ){
         push @{$$grid[$k]},$value;
        } else {
	 push @{$$grid[$k]},0.0;
        }
    }
}

###############################################################
sub gnorm{
###############################################################
# compute norm prefactor for real solid spherical harmonics GTO
# = sqrt[(2^{n+3/2} alpha^{n+1/2})/(Gamma(n+1/2))]
###############################################################

    ($alp,$l)=@_;
    $nrm=1.0;
    if($l == 0){
	$nrm=(2.0*$alp)**$d3b4*2.0*$pi4i;
    } elsif($l == 1){
	$nrm=(2.0*$alp)**$d5b4*$sq8b3*$pi4i;
    } elsif($l == 2){
	$nrm=(2.0*$alp)**$d7b4*$sq16b15*$pi4i;
    } elsif($l == 3){
	$nrm=(2.0*$alp)**$d9b4*4.0*$sq2b105*$pi4i;
#        print "implementation of f Gaussians to be checked before using";
#	exit;
    } elsif($l == 4){
        $nrm=(2.0*$alp)**$d11b4*8.0*$sq1b1155*$pi4i;
#        print "implementation of g Gaussians to be checked before using";
#       exit;
    } else{
        print "normalization for Gaussians with l > 4 not implemented";
	exit;
    }
}

###############################################################
sub basis_info{
###############################################################
# get basis info for atom type atype :
# number of primitives of each kind, radial part index
###############################################################

    ($atype,$b_count,$b_rad) = @_;
    foreach my $i (@basorder){
	@{$r_func{$i}}=();
    }
    $p=1;
    foreach my $j (@{$functions{$atype}}){
	foreach my $k (@{$shell{$ftype[$j]}}){
	    if( exists $map_prim{$k}){
		$k2=$map_prim{$k}
	    } else {
		$k2=$k;
	    }
	    push @{$r_func{$k2}}, $p;
	    if( ($ftype[$j] eq 'L') && ($k eq 'S')){
		$p++;
	    }
	}
	$p++;
    }

    @$b_count=();
    @$b_rad=();

    foreach my $i (@basorder2){
	if(exists $r_func{$i}){
	    push @$b_count, ($#{$r_func{$i}}+1);
#	    push @$b_count, -1 * ($#{$r_func{$i}}+1);
	    push @$b_rad, @{$r_func{$i}};
        } else {
	    push @$b_count, 0;
        }
    }

}

###############################################################
sub basis_info_cyrus{
###############################################################
# get basis info for atom type atype :
# number of primitives of each kind, radial part index
###############################################################

    ($atype,$b_count,$b_rad) = @_;
    foreach my $i (@basorder){
        @{$r_func{$i}}=();
    }
    $p=1;
    foreach my $j (@{$functions{$atype}}){
        foreach my $k (@{$shell{$ftype[$j]}}){
	    if (! $ispher) {
		if( exists $map_prim{$k}){
		    $k2=$map_prim{$k}
		} else {
		    $k2=$k;
		}
		push @{$r_func{$k2}}, $p;
	    } else {
		unless( exists $map_prim{$k}){
		    $k2=$k;
		    push @{$r_func{$k2}}, $p;
		}
	    }
            if( ($ftype[$j] eq 'L') && ($k eq 'S')){
                $p++;
            }
        }
        $p++;
    }

    @$b_count=();
    @$b_rad=();

    foreach my $i (@basorder3){
        if(exists $r_func{$i}){
            push @$b_count, ($#{$r_func{$i}}+1);
#            push @$b_count, -1 * ($#{$r_func{$i}}+1);
            push @$b_rad, @{$r_func{$i}};
        } else {
            push @$b_count, 0;
        }
    }

}

###############################################################
sub expand_shells{
###############################################################
# get complete list of primitive functions
# and compare them to labels in gamess orbital output
# also reorder them to be qmc friendly
###############################################################

    $count=0;

    for(my $i=0; $i <= $#atom_symbols; $i++){

	$a=$atom_symbols[$i];
	$p=$prim_radial{$a};

	foreach my $j (@{$functions{$a}}){
	    foreach my $k (@{$shell{$ftype[$j]}}){

		if($verbose > 1){
		    print "PRIM $count ";
		    print " atom index $lcao_atomidx[$count] | ",$i+1;
		    print " symbol $lcao_atomsym[$count] | $a";
		    print " label  $lcao_bflabel[$count] | $k";
		}


		if( ($lcao_atomsym[$count] eq $a) && ($lcao_atomidx[$count] == $i+1)
		    && ($lcao_bflabel[$count] eq $k)){
		    if($verbose > 1){
			print " OK \n";
		    }
		} else {
		    if($verbose > 1){
			print " MISMATCH! \n";
		    }
		    die "primitive functions not in expected order \n";
		}

		push @{$radial_part{$k}}, $p;
		push @{$prim_index{$k}}, $count;
		if( exists $map_prim{$k}){
		    $k2=$map_prim{$k}
		} else {
		    $k2=$k;
		}
		push @{$prim_index2{$k2}}, $count;
		if( ($ftype[$j] eq 'L') && ($k eq 'S')){
		    $p++;
		}
		$count++;
	    }
	    $p++;
	}
    }

    if($verbose > 1){
	print "reordered basis \n";
	foreach my $i (@basorder){
	  print "primitive function type $i , number of functions ",$#{$prim_index{$i}}+1," \n";
	    for(my $k=0; $k<=$#{$prim_index{$i}}; $k++){
	      print "$k primitive ",${$prim_index{$i}}[$k]," radial fn ",${$radial_part{$i}}[$k],"\n";
            }
	}
    }
}

###############################################################
sub transform_lcao{
###############################################################
# transformation from cartesian to spherical d, f and g functions
#
# 6d -> 1s,5d:
# 1 XX -> s = (1/sqrt(5)) [XX + YY + ZZ]
# 2 YY -> d(2z^2-x^2-y^2) = (1/2) [2*ZZ - XX - YY]
# 3 ZZ -> d(x^2-y^2) = (1/2) sqrt(3) [XX - YY]
#   XY -> d(xy) = XY
#   XZ -> d(xz) = XZ
#   YZ -> d(yz) = YZ
#
# 10f -> 3p,7f:
# 1 XXX -> p(x) = sqrt(3/7) [XXX + 1/sqrt(5) YYX + 1/sqrt(5) ZZX]
# 2 YYY -> p(y) = sqrt(3/7) [YYY + 1/sqrt(5) XXY + 1/sqrt(5) ZZY]
# 3 ZZZ -> p(z) = sqrt(3/7) [ZZZ + 1/sqrt(5) XXZ + 1/sqrt(5) YYZ]
# 4 YYX -> f(x^3-3*x*y^2) = (1/2) sqrt(5/2) [XXX - 3/sqrt(5) YYX]
# 5 XXY -> f(3*x^2*y-y^3) = (1/2) sqrt(5/2) [-YYY + 3/sqrt(5) XXY]
# 6 XXZ -> f(x^2*z-y^2*z) = (1/2) sqrt(3) [XXZ - YYZ]
#   XYZ -> f(x*y*z) = XYZ
# 7 ZZX -> f(4*x*z^2-x^3-x*y^2) = (1/2) sqrt(3/2) [-XXX - 1/sqrt(5) YYX + 4/sqrt(5) ZZX]
# 8 ZZY -> f(4*y*z^2-x^2*y-y^3) = (1/2) sqrt(3/2) [-YYY - 1/sqrt(5) XXY + 4/sqrt(5) ZZY]
# 9 YYZ -> f(2z^3-3*x^2*z-3*y^2*z) = (1/2) [2 ZZZ - 3/sqrt(5) XXZ - 3/sqrt(5) YYZ]
#
# 15g -> 1s,5d,9g:
#  1 XXXX -> s = sqrt(1/9) [XXXX + 2/sqrt(35/3) XXYY + 2/sqrt(35/3) XXZZ + YYYY + 2/sqrt(35/3) YYZZ + ZZZZ]
#  2 XXYY -> d(2z^2-x^2-y^2) = sqrt(5/9) 1/2 [-XXXX -2/sqrt(35/3) XXYY + 1/sqrt(35/3) XXZZ - YYYY + 1/sqrt(35/3) YYZZ + 2 ZZZZ]
#  3 XXZZ -> d(x^2-y^2) = sqrt(5/9) sqrt(3)/2 [XXXX + 1/sqrt(35/3) XXZZ - YYYY - 1/sqrt(35/3) YYZZ]
#  4 XXXY -> d(xy) = sqrt(5/9) sqrt(3) [1/sqrt(7) XXXY + 1/sqrt(7) YYYX + 1/sqrt(35) ZZXY]
#  5 XXXZ -> d(xz) = sqrt(5/9) sqrt(3) [1/sqrt(7) XXXZ + 1/sqrt(35) YYXZ + 1/sqrt(7) ZZZX]
#  6 XXYZ -> d(yz) = sqrt(5/9) sqrt(3) [1/sqrt(35) XXYZ + 1/sqrt(7) YYYZ + 1/sqrt(7) ZZZY]
#  7 YYYY -> g(l= 4) = sqrt(35)/8 [XXXX - 6/sqrt(35/3) XXYY + YYYY]
#  8 YYYX -> g(l=-4) = sqrt(35)/2 [1/sqrt(7) XXXY - 1/sqrt(7) YYYX]
#  9 YYXZ -> g(l= 3) = sqrt(35/2)/2 [1/sqrt(7) XXXZ - 3/sqrt(35) YYXZ]
# 10 YYYZ -> g(l=-3) = sqrt(35/2)/2 [3/sqrt(35) XXYZ - 1/sqrt(7) YYYZ]
# 11 YYZZ -> g(l= 2) = sqrt(5)/4 [-XXXX + 6/sqrt(35/3) XXZZ + YYYY - 6/sqrt(35/3) YYZZ]
# 12 ZZXY -> g(l=-2) = sqrt(5)/2 [-1/sqrt(7) XXXY -1/sqrt(7) YYYX + 6/sqrt(35) ZZXY]
# 13 ZZZX -> g(l= 1) = sqrt(5/2)/2 [-3/sqrt(7) XXXZ - 3/sqrt(35) YYXZ + 4/sqrt(7) ZZZX]
# 14 ZZZY -> g(l=-1) = sqrt(5/2)/2 [-3/sqrt(35) XXYZ - 3/sqrt(7) YYYZ + 4/sqrt(7) ZZZY]
# 15 ZZZZ -> g(l= 0) = 1/8 [3 XXXX + 6/sqrt(35/3) XXYY - 24/sqrt(35/3) XXZZ + 3 YYYY - 24/sqrt(35/3) YYZZ + 8 ZZZZ]
#
# The transformation matrix for the orbital coefficients is the transpose inverse of the above transformation matrix for the basi functions.
###############################################################

    for(my $k=0; $k<=$#{$prim_index{'XX'}}; $k++){
	$pxx=${$prim_index{'XX'}}[$k];
        $pyy=${$prim_index{'YY'}}[$k];
        $pzz=${$prim_index{'ZZ'}}[$k];
        $pxy=${$prim_index{'XY'}}[$k]; #JT
        $pxz=${$prim_index{'XZ'}}[$k]; #JT
        $pyz=${$prim_index{'YZ'}}[$k]; #JT
        for(my $i=0; $i < $orbitals; $i++){
          $a=${$lcao[$i]}[$pxx];
          $b=${$lcao[$i]}[$pyy];
          $c=${$lcao[$i]}[$pzz];
          $d=${$lcao[$i]}[$pxy]; #JT
          $e=${$lcao[$i]}[$pxz]; #JT
          $f=${$lcao[$i]}[$pyz]; #JT
          ${$lcao[$i]}[$pxx] = $lcao_cs * ($a+$b+$c) / 3.0;
          ${$lcao[$i]}[$pyy] = (2.0 * $c - $b - $a) /3.0;
          ${$lcao[$i]}[$pzz] = $lcao_cd * ($a - $b);
       }
   }

# f
    $sqrt2 = sqrt(2.0);
    $sqrt3 = sqrt(3.0);
    $sqrt5 = sqrt(5.0);
    $sqrt10 = sqrt(10.0);
    $sqrt21 = sqrt(21.0);
    $sqrt30 = sqrt(30.0);
    $sqrt2_15 = sqrt(2.0/15.0);
    $sqrt3_2 = sqrt(3.0/2.0);
    $sqrt7_15 = sqrt(7.0/15.0);

    for(my $k=0; $k<=$#{$prim_index{'XXX'}}; $k++){
	$pxxx=${$prim_index{'XXX'}}[$k];
        $pyyy=${$prim_index{'YYY'}}[$k];
        $pzzz=${$prim_index{'ZZZ'}}[$k];
        $pyyx=${$prim_index{'YYX'}}[$k];
        $pxxy=${$prim_index{'XXY'}}[$k];
        $pxxz=${$prim_index{'XXZ'}}[$k];
        $pzzx=${$prim_index{'ZZX'}}[$k];
        $pzzy=${$prim_index{'ZZY'}}[$k];
        $pyyz=${$prim_index{'YYZ'}}[$k];
        for(my $i=0; $i < $orbitals; $i++){
          $c1=${$lcao[$i]}[$pxxx];
          $c2=${$lcao[$i]}[$pyyy];
          $c3=${$lcao[$i]}[$pzzz];
          $c4=${$lcao[$i]}[$pyyx];
          $c5=${$lcao[$i]}[$pxxy];
          $c6=${$lcao[$i]}[$pxxz];
          $c7=${$lcao[$i]}[$pzzx];
          $c8=${$lcao[$i]}[$pzzy];
          $c9=${$lcao[$i]}[$pyyz];
          ${$lcao[$i]}[$pxxx] = $sqrt21*$c1/5.0 + $sqrt7_15*$c4 + $sqrt7_15*$c7;
          ${$lcao[$i]}[$pyyy] = $sqrt21*$c2/5.0 + $sqrt7_15*$c5 + $sqrt7_15*$c8;
          ${$lcao[$i]}[$pzzz] = $sqrt21*$c3/5.0 + $sqrt7_15*$c6 + $sqrt7_15*$c9;
          ${$lcao[$i]}[$pyyx] = $c1/$sqrt10 - $c4/$sqrt2;
          ${$lcao[$i]}[$pxxy] = -$c2/$sqrt10 + $c5/$sqrt2;
          ${$lcao[$i]}[$pxxz] = ($c6 - $c9)/$sqrt3;
          ${$lcao[$i]}[$pzzx] = -$sqrt3_2*$c1/5.0 - $c4/$sqrt30 + 2.0*$sqrt2_15*$c7;
          ${$lcao[$i]}[$pzzy] =  -$sqrt3_2*$c2/5.0 - $c5/$sqrt30 + 2.0*$sqrt2_15*$c8;
          ${$lcao[$i]}[$pyyz] = 2.0*$c3/5.0 - $c6/$sqrt5 - $c9/$sqrt5;
       }
   }

# g
    $sqrt7 = sqrt(7.0);
    $sqrt14 = sqrt(14.0);
    $sqrt21 = sqrt(21.0);
    $sqrt35 = sqrt(35.0);
    $sqrt70 = sqrt(70.0);
    $sqrt105 = sqrt(105.0);
    $sqrt3_7 = sqrt(3.0/7.0);
    $sqrt3_5 = sqrt(3.0/5.0);
    $sqrt2_35 = sqrt(2.0/35.0);
    $sqrt3_35 = sqrt(3.0/35.0);
    $sqrt7_15 = sqrt(7.0/15.0);
    $sqrt21_5 = sqrt(21.0/5.0);

    for(my $k=0; $k<=$#{$prim_index{'XXXX'}}; $k++){
	$pxxxx=${$prim_index{'XXXX'}}[$k];
        $pxxyy=${$prim_index{'XXYY'}}[$k];
        $pxxzz=${$prim_index{'XXZZ'}}[$k];
        $pxxxy=${$prim_index{'XXXY'}}[$k];
        $pxxxz=${$prim_index{'XXXZ'}}[$k];
        $pxxyz=${$prim_index{'XXYZ'}}[$k];
        $pyyyy=${$prim_index{'YYYY'}}[$k];
        $pyyyx=${$prim_index{'YYYX'}}[$k];
        $pyyxz=${$prim_index{'YYXZ'}}[$k];
        $pyyyz=${$prim_index{'YYYZ'}}[$k];
        $pyyzz=${$prim_index{'YYZZ'}}[$k];
        $pzzxy=${$prim_index{'ZZXY'}}[$k];
        $pzzzx=${$prim_index{'ZZZX'}}[$k];
        $pzzzy=${$prim_index{'ZZZY'}}[$k];
        $pzzzz=${$prim_index{'ZZZZ'}}[$k];
        for(my $i=0; $i < $orbitals; $i++){
          $c1=${$lcao[$i]} [$pxxxx];
          $c2=${$lcao[$i]} [$pxxyy];
          $c3=${$lcao[$i]} [$pxxzz];
          $c4=${$lcao[$i]} [$pxxxy];
          $c5=${$lcao[$i]} [$pxxxz];
          $c6=${$lcao[$i]} [$pxxyz];
          $c7=${$lcao[$i]} [$pyyyy];
          $c8=${$lcao[$i]} [$pyyyx];
          $c9=${$lcao[$i]} [$pyyxz];
          $c10=${$lcao[$i]}[$pyyyz];
          $c11=${$lcao[$i]}[$pyyzz];
          $c12=${$lcao[$i]}[$pzzxy];
          $c13=${$lcao[$i]}[$pzzzx];
          $c14=${$lcao[$i]}[$pzzzy];
          $c15=${$lcao[$i]}[$pzzzz];
          ${$lcao[$i]}[$pxxxx] = 3.0*$c1/5.0 + $sqrt7_15*$c2 + $sqrt7_15*$c3 + 3.0*$c7/5.0 + $sqrt7_15*$c11 + 3.0*$c15/5.0;
          ${$lcao[$i]}[$pxxyy] = -6.0*$c1/(7.0*$sqrt5) - 2.0*$c2/$sqrt21 + $c3/$sqrt21 - 6.0*$c7/(7.0*$sqrt5) + $c11/$sqrt21 + 12.0*$c15/(7.0*$sqrt5);
          ${$lcao[$i]}[$pxxzz] = 6.0*$sqrt3_5*$c1/7.0 + $c3/$sqrt7 - 6.0*$sqrt3_5*$c7/7.0 - $c11/$sqrt7;
          ${$lcao[$i]}[$pxxxy] = 3.0*$sqrt3_35*$c4 + 3.0*$sqrt3_35*$c8 + $sqrt3_7*$c12;
          ${$lcao[$i]}[$pxxxz] = 3.0*$sqrt3_35*$c5 + $sqrt3_7*$c9 + 3.0*$sqrt3_35*$c13;
          ${$lcao[$i]}[$pxxyz] = $sqrt3_7*$c6 +  3.0*$sqrt3_35*$c10 +  3.0*$sqrt3_35*$c14;
          ${$lcao[$i]}[$pyyyy] = $c1/$sqrt35 - $c2/$sqrt3 + $c7/$sqrt35;
          ${$lcao[$i]}[$pyyyx] = $c4/$sqrt5 - $c8/$sqrt5;
          ${$lcao[$i]}[$pyyxz] = $c5/$sqrt10 - $c9/$sqrt2;
          ${$lcao[$i]}[$pyyyz] = $c6/$sqrt2 - $c10/$sqrt10;
          ${$lcao[$i]}[$pyyzz] = -2.0*$c1/(7.0*$sqrt5) + 2.0*$c3/$sqrt21 + 2.0*$c7/(7.0*$sqrt5) - 2.0*$c11/$sqrt21;
          ${$lcao[$i]}[$pzzxy] = -$c4/$sqrt35 -$c8/$sqrt35 + 2.0*$c12/$sqrt7;
          ${$lcao[$i]}[$pzzzx] = -3.0*$c5/$sqrt70 - $c9/$sqrt14 + 2*$c13*$sqrt2_35;
          ${$lcao[$i]}[$pzzzy] = -$c6/$sqrt14 -3.0*$c10/$sqrt70 + 2*$c14*$sqrt2_35;
          ${$lcao[$i]}[$pzzzz] = 3.0*$c1/35.0 + $c2/$sqrt105 - 4.0*$c3/$sqrt105 + 3.0*$c7/35.0 - 4.0*$c11/$sqrt105 + 8.0*$c15/35.0;
       }
   }

}
###############################################################
sub transform_lcao_back{
###############################################################
# reverse of 'transform_lcao'
###############################################################

    for(my $k=0; $k<=$#{$prim_index{'XX'}}; $k++){
	$pxx=${$prim_index{'XX'}}[$k];
        $pyy=${$prim_index{'YY'}}[$k];
        $pzz=${$prim_index{'ZZ'}}[$k];
        for(my $i=0; $i < $orbitals; $i++){
          $a=${$lcao[$i]}[$pxx];
          $b=${$lcao[$i]}[$pyy];
          $c=${$lcao[$i]}[$pzz];
          ${$lcao[$i]}[$pxx] = $a/$lcao_cs - $b/2.0 + $c / (2.0*$lcao_cd);
	  ${$lcao[$i]}[$pyy] = $a/$lcao_cs - $b/2.0 - $c / (2.0*$lcao_cd);
          ${$lcao[$i]}[$pzz] = $a/$lcao_cs + $b;

          # print "transform_lcao_back : $i $pxx $pyy $pzz\n";

       }
   }
}

###############################################################
sub print_qmc_bf_info{
###############################################################

    open(BFINFOFILE,"> $bf_info_file") || die "Can not open file $bf_info_file: $!\n";
    printf BFINFOFILE "qmc_bf_info 1\n";
    foreach my $a (@atom_types){
	@c=();
	@r=();
	basis_info($a,\@c,\@r);
	printf BFINFOFILE "%s\n", join(" ", @c);
	printf BFINFOFILE "%s\n", join(" ", @r);
    }
    printf BFINFOFILE "end\n";
    close(BFINFOFILE);
}

###############################################################
sub print_lcao{
###############################################################
    open(LCAOFILE,"> $lcao_file") || die  "cant open file $lcao_file : $!";
# info
    printf LCAOFILE "# orbitals from run %s\n",$run_title;
    printf LCAOFILE "# orbital  type %s \n",$orbnames[$orbtype];

# orbitals to be printed
    if($porb == 0){
	$porb=$orbitals;
    }
    if( $omit_unused_orbitals && $make_det_file ){
	@orbital_indices=sort { $a <=> $b } keys %used_orbitals;
	$porb=$#orbital_indices + 1;
    } else {
	for(my $j=0; $j<$porb; $j++){
	    $orbital_indices[$j]=$j;
	}
    }
# irrep info
    if($#irrep_strings > -1){
	%irreps=();
	$irrep_num=0;
	@irrep_index=();
	for($j=0; $j<$orbitals;$j++){
	    if( ! exists $irreps{$irrep_strings[$j]}){
		$irrep_num++;
		$irreps{$irrep_strings[$j]}=$irrep_num;
		$idx=$irrep_num;
	    } else {
		$idx=$irreps{$irrep_strings[$j]};
	    }
	    $irrep_index[$j]=$idx;
	}
	if($verbose){
	    for(my $i=0; $i<=$#orbital_indices; $i++){
		printf "used orbital %d : %d irrep %d \n",$i+1, $orbital_indices[$i]+1,$irrep_index[$orbital_indices[$i]];
	    }
	}
	if($make_symmetry_file){
	    open(SYMFILE,"> $sym_info_file") || die "Can not open file $sym_info_file: $!\n";

	    printf SYMFILE "sym_labels %d %d\n",$irrep_num,$porb;
	    for my $j (sort(keys(%irreps))){
		printf SYMFILE "%d %s ",$irreps{$j},$j;
	    }
	    printf SYMFILE "\n";
	    foreach my $j (@orbital_indices){
		printf SYMFILE "%d ",$irrep_index[$j];
	    }
	    printf SYMFILE "\nend\n";
	}
    }
# LCAO coefficients
    printf LCAOFILE "lcao %d %d \n",$porb,$#lcao_bflabel+1;
# print out coefficients ordered by atoms and
# within each atom by the sequence given in the array basorder
# this loop is a bit ugly since we loop over the complete set
# of functions for each atom, the reason is the messy way of
# simulating multi-dimensional arrays
    foreach my $j (@orbital_indices){
	for(my $ia=0; $ia <= $#atom_symbols; $ia++){
# debugging only
#	    print LCAOFILE "### atom $ia  ",$atom_symbols[$ia]," \n";
#
	    foreach my $i (@basorder){
		for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
		    $pk=${$prim_index2{$i}}[$k];
		      if($lcao_atomidx[$pk] == ($ia+1)){
		         printf LCAOFILE $lcao_format, ${$lcao[$j]}[$pk];
	              }
	       }
            }
        }
        printf  LCAOFILE "\n";
   }
   printf  LCAOFILE "end\n";
   printf ("Writing basis info and lcao coefficients to $lcao_file\n")  if(! $quiet);
   close(LCAOFILE);
}

###############################################################
sub print_gamess_vec{
###############################################################
# print current lcao in GAMESS' VEC format
###############################################################
    open(VECFLE,"> $new_vec_file") || die "can not open VEC file $new_vec_file : $!\n";
    $nb=$#lcao_bflabel+1;
    $ncol=5;

    print "basis fn $nb orbitals $orbitals\n";

    printf VECFLE " \$VEC";
    for(my $i=0; $i<$orbitals; $i++){
      $nff=1;
      $c=0;
      for(my $j=0; $j<$nb; $j++){
	if(--$nff == 0){
	    $c++;	
	    printf VECFLE "\n%2d%3d",($i+1)%100,$c%100;
	    $nff=$ncol;
	}
#JT	printf VECFLE "% 15.8E",${$lcao[$i]}[$j];
	printf VECFLE "% 19.12E",${$lcao[$i]}[$j];  #JT
      }
    }
    printf VECFLE "\n \$END\n";
    close(VECFLE);
}

###############################################################
sub print_geometry{
###############################################################
# write out geometry info (coordinates and types)
###############################################################
    open(GEOFILE,"> $geometry_file") || die  "cant open file $geometry_file : $!";
    printf GEOFILE "# geometry from run %s \n",$run_title;
    printf GEOFILE "&atoms nctype %d natom %d\n", $#atom_types+1, $#atom_symbols+1;
    %atom_type_index=();
    printf GEOFILE "&atom_types ";
    for(my $i=0; $i<= $#atom_types; $i++){
	$atom_type_index{$atom_types[$i]}=$i;
	printf  GEOFILE " %d %s ",$i+1,$atom_types[$i];
    }
    printf  GEOFILE "\n";

    printf GEOFILE "geometry\n";
    for(my $i=0; $i<= $#atom_symbols; $i++){
	printf GEOFILE "% f % f % f %d\n", $atom_x[$i],$atom_y[$i],$atom_z[$i],$atom_type_index{$atom_symbols[$i]}+1;
    }
    printf GEOFILE "end\n";

    printf GEOFILE "znuc\n";
    foreach my $i (@atom_types){
	if( exists $zcore{$i} ){
	    $z=$zatom{$i}-$zcore{$i};
	} else {
	    $z=$zatom{$i};
	}
	printf GEOFILE "%f ",$z;
    }
    printf GEOFILE "\nend\n";

    close(GEOFILE);
    printf ("geometry information written to file $geometry_file\n") if(! $quiet);
}

###############################################################
sub print_cyrus_input{
###############################################################

    open(CYRFILE,"> $cyrus_input_file") || die  "cant open file $cyrus_input_file : $!";

# Header Section

#   printf CYRFILE "ncsf=%d ndet=%d norb=%d 1837465927472523 title, irn\n",$ncsf,$selected_det,$porb;
    printf CYRFILE "'ncsf=%d ndet=%d norb=%d'                title\n",$ncsf,$selected_det,$porb;
    printf CYRFILE "1837465927472523                         irn\n";
    if ($gauss_slater_functions) {
	printf CYRFILE "0 1 gauss-slater                             iperiodic,ibasis,which_analytical_basis\n";
    }
    elsif ($slater_functions) {
	printf CYRFILE "0 1 slater                               iperiodic,ibasis,which_analytical_basis\n";
    }
    else {
	printf CYRFILE "0 1 gaussian                             iperiodic,ibasis,which_analytical_basis\n";
    }
    printf CYRFILE "0.5  %7.2f  '  Hartrees'               hb,etrial,eunit\n",$total_energy;
    printf CYRFILE "100   100  1   100   0                   nstep,nblk,nblkeq,nconf,nconf_new\n";
    printf CYRFILE "0    0    1    -2                        idump,irstar,isite,ipr\n";
    printf CYRFILE "6  1.  5.  1.  1.                        imetro delta,deltar,deltat fbias\n";
    printf CYRFILE "2 1 1 1 1 0 0 0 0                        idmc,ipq,itau_eff,iacc_rej,icross,icuspg,idiv_v,icut_br,icut_e\n";
    if($ecp){
    printf CYRFILE "50  .1                                   nfprod,tau\n";
    }
    else{
    printf CYRFILE "50  .01                                  nfprod,tau\n";
    }

    if($ecp){
     printf CYRFILE "6 -1   1  0                              nloc,numr,nforce,nefp\n";
     printf CYRFILE "6                                        nquad\n";
    }
    else{ 
	    if($analytic_basis){
    printf CYRFILE "0  -3   1  0                             nloc,numr,nforce,nefp\n";
            }
	    else
	    {
    printf CYRFILE "0  1   1  0                              nloc,numr,nforce,nefp\n";
	    }
    }

    printf CYRFILE "%d %d \t \t \t \t \t nelec,nup\n\n",$nalpha+$nbeta,$nalpha;

# Geometry section

    printf CYRFILE "'* Geometry section'\n";

    printf CYRFILE "3 \t \t \t \t \t ndim\n";
    printf CYRFILE "%d %d \t \t \t \t \t nctype,ncent\n",$#atom_types+1, $#atom_symbols+1;
    $nctype=$#atom_types+1;

# iwctype

    %atom_type_index=();
    for(my $i=0; $i<= $#atom_symbols; $i++){
        $atom_type_index{$atom_types[$i]}=$i;
        printf CYRFILE "%d ", $atom_type_index{$atom_symbols[$i]}+1;
    }
    printf CYRFILE  "(iwctype(i),i=1,ncent)\n";

# znuc

    foreach my $i (@atom_types){
        if( exists $zcore{$i} ){
            $z=$zatom{$i}-$zcore{$i};
        } else {
            $z=$zatom{$i};
        }
        printf CYRFILE "%2.1f ",$z;
    }
    printf CYRFILE "(znuc(i),i=1,nctype)\n";

# lpotp1: print default values for now

    if($ecp){     #JT
    foreach my $i (@atom_types){
        if( exists $zcore{$i} ){
            $z=$lpotp1{$i};
        } else {
            $z=0;
        }
        printf CYRFILE "%d ",$z;
    }
    printf CYRFILE "(lpotp1(i),i=1,nctype)\n";
   }

    for(my $i=0; $i<= $#atom_symbols-1; $i++){
        printf CYRFILE "%12.8f %12.8f %12.8f %d\n", $atom_x[$i],$atom_y[$i],$atom_z[$i],$atom_type_index{$atom_symbols[$i]}+1;
    }
    printf CYRFILE "%12.8f %12.8f %12.8f %d ((cent(k,i),k=1,3),i=1,ncent)\n\n", $atom_x[$#atom_symbols],$atom_y[$#atom_symbols],$atom_z[$#atom_symbols],$atom_type_index{$atom_symbols[$#atom_symbols]}+1;

# Determinantal section

# orbitals to be printed

    if($porb == 0){
        $porb=$orbitals;
    }

    if( $omit_unused_orbitals && $make_det_file ){
        @orbital_indices=sort { $a <=> $b } keys %used_orbitals;
        $porb=$#orbital_indices + 1;
    } else {
        for(my $j=0; $j<$porb; $j++){
            $orbital_indices[$j]=$j;
        }
    }

    printf CYRFILE "'* Determinantal section'\n";
    printf CYRFILE "0 0 'tm' \t \t \t \t inum_orb,iorb_used,iorb_format\n";
    printf CYRFILE "%d %d %d \t \t \t \t ndet,nbasis,norb\n",$selected_det,$nbasis,$porb;

#basis function info

    foreach my $a (@atom_types){
        @c=();
        @r=();
        basis_info_cyrus($a,\@c,\@r);
#	if($analytic_basis){ #JT
# printf CYRFILE "%s  0   0  0 0 0   0  0 0 0  0 0 0 0 0   0  0 0 0  0 0 0 0 0  0  0 0 0  0 0 0 0 0 n1s...4pz,sa,pa,da\n";
#	    print CYRFILE "  $n1s{$a}   $n2s{$a}  $n2p{$a} $n2p{$a} $n2p{$a}   $n3s{$a}  $n3p{$a} $n3p{$a} $n3p{$a}  $n3d{$a} $n3d{$a} $n3d{$a} $n3d{$a} $n3d{$a}   $n4s{$a}  $n4p{$a} $n4p{$a} $n4p{$a}  $n4d{$a} $n4d{$a} $n4d{$a} $n4d $n4d{$a}  $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a}   $n5s{$a}  $n5p{$a} $n5p{$a} $n5p{$a}  $n5d{$a} $n5d{$a} $n5d{$a} $n5d{$a} $n5d{$a}  $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a}   $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a}  0  0 0 0  0 0 0 0 0 n1s,n2s,n2px,n2py,np2z,...,n5g,sa,pa,da\n";
#        }
#        else
#	{
#        printf CYRFILE "%s ns,np,nd,nf,ng,nh (for pseudo sys. principal quantum number is irrelevant)\n", join(" ", @c);
    print CYRFILE "  $n1s{$a}   $n2s{$a}  $n2p{$a} $n2p{$a} $n2p{$a}   $n3s{$a}  $n3p{$a} $n3p{$a} $n3p{$a}  $n3d{$a} $n3d{$a} $n3d{$a} $n3d{$a} $n3d{$a}   $n4s{$a}  $n4p{$a} $n4p{$a} $n4p{$a}  $n4d{$a} $n4d{$a} $n4d{$a} $n4d $n4d{$a}  $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a} $n4f{$a}   $n5s{$a}  $n5p{$a} $n5p{$a} $n5p{$a}  $n5d{$a} $n5d{$a} $n5d{$a} $n5d{$a} $n5d{$a}  $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a} $n5f{$a}   $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a} $n5g{$a}  0  0 0 0  0 0 0 0 0 n1s,n2s,n2px,n2py,np2z,...,n5g,sa,pa,da\n";
        printf CYRFILE "%s (iwrwf(ib),ib=1,nbastyp)\n", join(" ", @r);
	}
   # }

# irrep info

    if($#irrep_strings > -1){
        %irreps=();
        $irrep_num=0;
        @irrep_index=();
        for($j=0; $j<$orbitals;$j++){
            if( ! exists $irreps{$irrep_strings[$j]}){
                $irrep_num++;
                $irreps{$irrep_strings[$j]}=$irrep_num;
                $idx=$irrep_num;
            } else {
                $idx=$irreps{$irrep_strings[$j]};
            }
            $irrep_index[$j]=$idx;
        }
    }

    my @final_lcao_coef=();
    foreach my $j (@orbital_indices){
	my @temp_lcao_coef=();
        for(my $ia=0; $ia <= $#atom_symbols; $ia++){
            foreach my $i (@basorder){
                for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
                    $pk=${$prim_index2{$i}}[$k];
                      if($lcao_atomidx[$pk] == ($ia+1)){
			  my $temp_lcao_coef=sprintf "% .8E", ${$lcao[$j]}[$pk];
			  push @temp_lcao_coef, $temp_lcao_coef;
                      }
               }
            }
        }
	push @final_lcao_coef, [@temp_lcao_coef];
    }

    my @which_basis_used=();
    my $reduced_nbasis=0;
    if ($ispher == 1) {
	print "Removing redundant basis functions\n";
	my $tolerance = 10e-06;
	for my $current_basis (0..$nbasis-1) {
	    $current_basis_used=0;
	    for my $current_orb (@orbital_indices) {
		$current_basis_used = 1 if abs(${$final_lcao_coef[$current_orb]}[$current_basis]) > $tolerance;
	    }
	    push @which_basis_used, $current_basis if $current_basis_used;
	}

	for my $current_orb (@orbital_indices) {
	    @{$final_lcao_coef[$current_orb]} = @{$final_lcao_coef[$current_orb]}[@which_basis_used]; 
	}
	$reduced_nbasis = @{$final_lcao_coef[0]};
    }
    push @{$final_lcao_coef[0]}, "((coef(ibasis,iorb),ibasis=1,nbasis),iorb=1,norb)";
    print CYRFILE " @{$_}\n" for @final_lcao_coef;


# screening contants
    if($analytic_basis){
	if ($ispher == 1) {
	    @exponents_slater_ordered = @exponents_slater_ordered[@which_basis_used];
	}
	printf CYRFILE "@exponents_slater_ordered";
    }
    else{
	process_slater_exponents();
	if ($ispher == 1) {
	    @exponents_slater_ordered = @exponents_slater_ordered[@which_basis_used];
	}
	printf CYRFILE "@exponents_slater_ordered";
     }
    printf CYRFILE " (zex(i),i=1,nbasis)";

# CSFs and determinants

    # print unique determinants
    if ($detread) {

      for($i=1; $i<=$selected_det; $i++){
        printf CYRFILE "\n";
        @ocsym=split '',$sorted_detlist[$kept_det[$i]];
        for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '+') || ($ocsym[$j] eq '2')){
                if($omit_unused_orbitals){
                    printf CYRFILE "%3d ",$orb_index{$j}+1;
                } else {
                    printf CYRFILE "%3d ",$j+1;
                }
            }
        }
        printf CYRFILE  "    ";
        for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '-') || ($ocsym[$j] eq '2')){
                if($omit_unused_orbitals){
                    printf CYRFILE "%3d ",$orb_index{$j}+1;
                } else {
                    printf CYRFILE "%3d ",$j+1;
                }
            }
        }
      }

    } else {

        printf CYRFILE  "\n";
        for($j=0; $j<$nalpha; $j++){
           printf CYRFILE "%d ",$j+1;
        }
        printf CYRFILE " ";
        for($j=0; $j<$nbeta; $j++){
           printf CYRFILE "%d ",$j+1;
        }
    }
    printf CYRFILE "(iworbd(j,idet),j=1,nelec)\n";

   # print CSFs
   if ($detread) {

      # print csf_trial
      printf CYRFILE "%d ncsf\n",$ncsf;

      # print csf_coef
      for($i=1; $i<=$ncsf; $i++){
        printf CYRFILE "%s ",@csf_coef[$i]
      }
      printf CYRFILE " (csf_coef(icsf),icsf=1,ncsf)\n";

      # num dets in each csf
      for($i=1; $i<=$ncsf; $i++){
        printf CYRFILE "%d ",$csf_ndet[$i];
      }
      printf CYRFILE " (ndet_in_csf(icsf),icsf=1,ncsf)\n";

      # print csf
      for($i=1; $i<=$ncsf; $i++){

        # print dets
        foreach $d (@{$csf_trial[$i]}){
          $cdet=$$d{det};
          for($j=1; $j<=$selected_det; $j++){
            if ($kept_det[$j]==$cdet) {
               $kdet=$j;
            }
          }
          printf CYRFILE "%2d ",$kdet;
        }
        printf CYRFILE " (iwdet_in_csf(idet_in_csf,%d),idet_in_csf=1,ndet_in_csf(%d))\n",$i,$i;

        # print coefs
        foreach $d (@{$csf_trial[$i]}){

          printf CYRFILE "%s ",$$d{coef}*$phase_factors[$$d{det}]*$qmc_phase[$$d{det}];
        }
        printf CYRFILE " (cdet_csf(idet_in_csf,%d),idet_in_csf=1,ndet_in_csf(%d))\n",$i,$i;

      }

    } else {

      printf CYRFILE "1 ncsf\n";
      printf CYRFILE "1. (csf_coef(icsf),icsf=1,ncsf)\n";
      printf CYRFILE "1  (ndet_in_csf(icsf),icsf=1,ncsf)\n";
      printf CYRFILE "1  (iwdet_in_csf(idet_in_csf,1),idet_in_csf=1,ndet_in_csf(1))\n";
      printf CYRFILE "1. (cdet_csf(idet_in_csf,1),idet_in_csf=1,ndet_in_csf(1))\n";

    }
    printf CYRFILE "\n";

# Jastrow section

   $norda=5;
   $nordb=5;
   $nordc=5;
   printf CYRFILE "'* Jastrow section'\n";
   printf CYRFILE "1             ianalyt_lap\n";
   printf CYRFILE "4 4 1 1 5 0   ijas,isc,nspin1,nspin2,nord,ifock\n";
   if($no_jastrow){
   printf CYRFILE "0 0 0         norda,nordb,nordc\n";
   }else{
   printf CYRFILE "%d %d %d         norda,nordb,nordc\n",$norda,$nordb,$nordc;
   }
   if($ecp) {
   printf CYRFILE "0.4 0. scalek,a21\n";
   }else{ printf CYRFILE "0.8 0. scalek,a21\n";
   }

   for($j=0; $j<$nctype; $j++){
    printf CYRFILE "0. 0. 0. 0. 0. 0. (a(iparmj),iparmj=1,nparma)\n";
   }
   if($no_jastrow){
    printf CYRFILE "0. 0. 0. 0. 0. 0. (b(iparmj),iparmj=1,nparmb)\n";
   }else{
    printf CYRFILE "0.5 1. 0. 0. 0. 0. (b(iparmj),iparmj=1,nparmb)\n";
   }
   for($j=0; $j<$nctype; $j++){
    printf CYRFILE "0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. (c(iparmj),iparmj=1,nparmc)\n";
   }
   printf CYRFILE "\n";

# Optimization section

   printf CYRFILE "'* Optimization section'\n";
   if($no_jastrow){
   printf CYRFILE "0 10000 1.d-8 0.05 1.d-4     nopt_iter,nblk_max,add_diag(1),p_var,tol_energy\n";
   }else{
   printf CYRFILE "10 10000 1.d-8 0.05 1.d-4     nopt_iter,nblk_max,add_diag(1),p_var,tol_energy\n";
   }

   if($ecp){
    printf CYRFILE "1000 %d -1 1 5 1000 21101 1 NDATA,NPARM,icusp,icusp2,NSIG,NCALLS,iopt,ipr\n",4*$nctype+5+15*$nctype+$ncsf-1;
   }
   else{
    printf CYRFILE "1000 %d 1 1 5 1000 21101 1 NDATA,NPARM,icusp,icusp2,NSIG,NCALLS,iopt,ipr\n",4*$nctype+5+15*$nctype+$ncsf-1;
   }

   printf CYRFILE "0 0 0 0 i3body,irewgt,iaver,istrech\n";
   printf CYRFILE "0 0 0 0 0 0 0 0 0 0 ipos,idcds,idcdr,idcdt,id2cds,id2cdr,id2cdt,idbds,idbdr,idbdt\n";

   for($j=0; $j<$porb; $j++){
   printf CYRFILE "1 ";
   }
   printf CYRFILE "(lo(iorb),iorb=1,norb)\n";

# nparml
   printf CYRFILE "0  ";
# nparma
   for($j=0; $j<$nctype; $j++){
   printf CYRFILE "4 ";
   }
# nparmb
   printf CYRFILE " 5  ";
# nparmc
   for($j=0; $j<$nctype; $j++){
   printf CYRFILE "15 ";
   }
# nparmf
   for($j=0; $j<$nctype; $j++){
   printf CYRFILE " 0";
   }
# nparmcsf/s/g
   printf CYRFILE "  %d 0 0  nparml,nparma,nparmb,nparmc,nparmf,nparmcsf,nparms,nparmg\n",$ncsf-1;

   printf CYRFILE "    (iworb(iparm),iwbasi(iparm),iparm=1,nlarml)\n";
   printf CYRFILE "    (iwbase(iparm),iparm=1,nparm-nparml)\n";

   printf CYRFILE "  ";
   for($j=2; $j<=$ncsf; $j++){
   printf CYRFILE "%d ",$j;
   }
   printf CYRFILE "(iwcsf(iparm),iparm=1,nparmcsf)\n";

   for($j=0; $j<$nctype; $j++){
    printf CYRFILE "    3 4 5 6 (iwjasa(iparm),iparm=1,nparma)\n";
   }
   printf CYRFILE "2 3 4 5 6 (iwjasb(iparm),iparm=1,nparmb)\n";
   for($j=0; $j<$nctype; $j++){
    printf CYRFILE "    3   5   7 8 9    11    13 14 15 16 17 18    20 21    23 (iwjasc(iparm),iparm=1,nparmc)\n";
   }

   printf CYRFILE "0 0       necn,nebase\n";
   printf CYRFILE "          ((ieorb(j,i),iebasi(j,i),j=1,2),i=1,necn)\n";
   printf CYRFILE "          ((iebase(j,i),j=1,2),i=1,nebase)\n";

   for($j=0; $j<$porb; $j++){
   printf CYRFILE "0 ";
   }
   printf CYRFILE "(ipivot(j),j=1,norb)\n";

   printf CYRFILE "%5.2f eave\n",$total_energy;
   printf CYRFILE "1.d-6 5. 1 15 4 pmarquardt,tau,noutput,nstep,ibold\n";
   printf CYRFILE "T F analytic,cholesky\n";
    if($options_JT){
	printf CYRFILE "end\n";
	printf CYRFILE "\n";

	printf CYRFILE "basis\n";
	if ($gauss_slater_functions) {
	    printf CYRFILE " which_analytical_basis = gauss-slater \n";
	}
	elsif ($slater_functions) {
	    printf CYRFILE " which_analytical_basis = slater \n";
	}
	else{
	    printf CYRFILE " which_analytical_basis = gaussian \n";
	}
	my $which_opt_exp = 1;
	my @optimized_exponents=();
	for (0..$#exponents_slater_ordered) {
	    if ($exponents_slater_ordered[$_] != 0) {
		push @optimized_exponents, $which_opt_exp;
	    }
	    $which_opt_exp++;
	}
	printf CYRFILE "optimized_exponents ";
	printf CYRFILE  join(" ",@optimized_exponents);
	printf CYRFILE " end\n";
	printf CYRFILE "end\n";
	printf CYRFILE "\n";
	

	# print orbital information
	printf CYRFILE "orbitals\n";

	# print orbital eigenvalues
	printf CYRFILE " energies\n";
	for($i=0; $i<$porb; $i++){
	    printf CYRFILE "$orbital_eigenvalues[@orbital_indices[$i]] ";
	}
	printf CYRFILE "\n end\n";

	# print symmetry info
	printf CYRFILE " symmetry\n";

	if($#irrep_strings > -1){
	    %irreps=();
	    $irrep_num=0;
	    @irrep_index=();
	    for($j=0; $j<$orbitals;$j++){
		if( ! exists $irreps{$irrep_strings[$j]}){
		    $irrep_num++;
		    $irreps{$irrep_strings[$j]}=$irrep_num;
		    $idx=$irrep_num;
		} else {
		    $idx=$irreps{$irrep_strings[$j]};
		}
		$irrep_index[$j]=$idx;
	    }
            foreach my $j (@orbital_indices){
#JT                printf CYRFILE "%d ",$irrep_index[$j];
                printf CYRFILE "%s ",$irrep_strings[$j];  #JT print label of irrep instead of index
            }
	}

	printf CYRFILE "\n end\n";

	printf CYRFILE "end\n";
	printf CYRFILE "\n";

	# print optimization menu
	if($no_jastrow != 1){
	    printf CYRFILE "optimization\n";
	    printf CYRFILE " parameters jastrow end\n";
	    printf CYRFILE " method = linear\n";
	    printf CYRFILE "!linear renormalize=true end\n";
	    printf CYRFILE " increase_blocks=true\n";
	    printf CYRFILE " increase_blocks_factor=1.4\n";
	    printf CYRFILE "!casscf=true\n";
	    printf CYRFILE "!check_redundant_orbital_derivative=false\n";
	    printf CYRFILE "!do_add_diag_mult_exp=.true.\n";
	}
	    if($trial_state != 1){
		printf CYRFILE "\n";
		printf CYRFILE "! For doing excited states.  The option we are using here is to optimize mostly the energy (p_var~0) and look for the nth state above the gnd. state\n";
		printf CYRFILE "! In this case it also uses as a criterion that the change has a small norm.\n";
		printf CYRFILE "! The other option is to mostly optimize the variance (p_var~1)and use garget_stattate_above_groundstate_or_target_smallest_norm = 0 because the targeted excited state has the smallest variance.\n";
		printf CYRFILE "linear\n";
		printf CYRFILE "! target_state=%d\n",$trial_state;
		printf CYRFILE "! target_state_above_groundstate = %d\n",$trial_state-1;
		printf CYRFILE "  target_state_above_groundstate_or_target_smallest_norm = %d\n",$trial_state-1;
		printf CYRFILE "  eigval_lower_bound=%7.2f\n",$total_energy-0.5;
		printf CYRFILE "  eigval_upper_bound=%7.2f\n",$total_energy+0.1;
		printf CYRFILE " end\n";
		printf CYRFILE " stabilize=false\n";
	    }
            printf CYRFILE "end\n";
            printf CYRFILE "\n";
    } # end if($options_JT)

    close(CYRFILE);
    printf ("Cyrus format input file written to $cyrus_input_file\n") if(! $quiet);
    if($ecp){
    printf ("  Warning: verify values of lpotp1 especially for H ECP \n") if(! $quiet);
    }

    if ($ispher == 1) {
	open(CYRFILE,"< $cyrus_input_file") || die  "cant open file $cyrus_input_file : $!"; 
	my @temp_file_contents = <CYRFILE>;
	close(CYRFILE);
	for (@temp_file_contents) {
	    if (/nbasis,norb/) {
		s/^\s*(\d+)\s+\d+\s+(\d+)/$1 $reduced_nbasis $2/;
	    }
	}
	open(CYRFILE,"> $cyrus_input_file") || die  "cant open file $cyrus_input_file : $!"; 
	print CYRFILE @temp_file_contents;
    }
    
# print also file in new format
  if($make_new_file){
    print_new_input();
  }

}

###############################################################
sub print_new_input{
###############################################################

    open(NEWFILE,"> $new_input_file") || die  "cant open file $new_input_file : $!";

# control menu

    printf NEWFILE $ftype;
    printf NEWFILE "control\n";
    printf NEWFILE " seed = 1837465927472523\n";
    printf NEWFILE " etrial=%7.2f\n",$total_energy;
    printf NEWFILE " nstep=100 nblk=100 nblkeq=1 nconf=100\n";
    if($ecp){
    printf NEWFILE " tau=0.1\n";
    }
    else{
    printf NEWFILE " tau=0.01\n";
    }
    printf NEWFILE "end\n\n";

# nuclei menu

    printf NEWFILE "nuclei\n";
    if($ecp){
     printf NEWFILE " nloc=6\n";
     printf NEWFILE " nquad=6\n";
    }

# lpotp1: print default values for now

    if($ecp){
      printf NEWFILE " lpotp1 ";
      foreach my $i (@atom_types){
        if( exists $zcore{$i} ){
            $z=$lpotp1{$i};
        } else {
            $z=0;
        }
        printf NEWFILE "%d ",$z;
      }
    printf NEWFILE " end\n";
    }

    %atom_type_index=();
    for(my $i=0; $i<= $#atom_symbols; $i++){
       $atom_type_index{$atom_types[$i]}=$i;
    }

    printf NEWFILE " geometry\n";
    for(my $i=0; $i<= $#atom_symbols; $i++){
        if( exists $zcore{$atom_types[$atom_type_index{$atom_symbols[$i]}]} ){
            $z=$zatom{$atom_types[$atom_type_index{$atom_symbols[$i]}]}-$zcore{$atom_types[$atom_type_index{$atom_symbols[$i]}]};
        } else {
            $z=$zatom{$atom_types[$atom_type_index{$atom_symbols[$i]}]};
        }
        printf NEWFILE "  %d %2.1f %12.8f %12.8f %12.8f\n", $atom_type_index{$atom_symbols[$i]}+1,$z, $atom_x[$i],$atom_y[$i],$atom_z[$i];
    }

    printf NEWFILE " end\n";
    printf NEWFILE "end\n\n";

# wavefunction menu
    printf NEWFILE "wavefunction\n";
    printf NEWFILE " nelec=%d nup=%d\n",$nalpha+$nbeta,$nalpha;
    printf NEWFILE "end\n\n";

# basis menu

    printf NEWFILE "basis\n";
    if($ecp || !$analytic_basis){
#     printf NEWFILE " numr=1\n";
     printf NEWFILE " radial_basis_type = numerical-analytical\n";
    }
    if ($gauss_slater_functions) {
     printf NEWFILE " which_analytical_basis = gauss-slater \n";
    }



    printf NEWFILE " basis_functions";

    if($analytic_basis){
#     make list of basis functions by atom type for new input
      process_basis_functions_by_atom_type(); 
      process_slater_exponents_by_atom_type();
      foreach my $a (@atom_types){
        printf NEWFILE "\n%d",$atom_type_index{$a}+1;
        $i=-1;
        foreach my $b (@{$basis_functions_by_atom_type{$a}}){
        $i=$i+1; 
        printf NEWFILE "\n$b   ${$exponents_slater_ordered_by_atom_type{$a}}[$i]";
        }
      }
    }
    else{
      process_basis_functions_by_atom_type(); 
      process_slater_exponents_by_atom_type(); #JT
      foreach my $a (@atom_types){
        @c=();
        @r=();
        basis_info_cyrus($a,\@c,\@r);
        printf NEWFILE "\n%d",$atom_type_index{$a}+1;
        $i=-1;
        foreach my $b (@{$basis_functions_by_atom_type{$a}}){
        $i=$i+1; 
        printf NEWFILE "\n$b  ${$exponents_slater_ordered_by_atom_type{$a}}[$i]  $r[$i]";
        }
      }
    }

    printf NEWFILE "\n end\n";

#    printf NEWFILE " exponents\n";
#    if($analytic_basis){
#     printf NEWFILE "@exponents_slater_ordered";
#    }
#    else{
#     for($j=0; $j<$nbasis; $j++){
#       printf NEWFILE "1. ";
#     }
#    }
#    printf NEWFILE "\n end\n";


    printf NEWFILE "end\n\n";

# orbitals menu

    printf NEWFILE "orbitals\n";

#   orbitals to be printed

    if($porb == 0){
        $porb=$orbitals;
    }

    if( $omit_unused_orbitals && $make_det_file ){
        @orbital_indices=sort { $a <=> $b } keys %used_orbitals;
        $porb=$#orbital_indices + 1;
    } else {
        for(my $j=0; $j<$porb; $j++){
            $orbital_indices[$j]=$j;
        }
    }


# irrep info

    if($#irrep_strings > -1){
        %irreps=();
        $irrep_num=0;
        @irrep_index=();
        for($j=0; $j<$orbitals;$j++){
            if( ! exists $irreps{$irrep_strings[$j]}){
                $irrep_num++;
                $irreps{$irrep_strings[$j]}=$irrep_num;
                $idx=$irrep_num;
            } else {
                $idx=$irreps{$irrep_strings[$j]};
            }
            $irrep_index[$j]=$idx;
        }
    }

    printf NEWFILE " coefficients\n";

############################################################################"
#    foreach my $j (@orbital_indices){
#
#        for(my $ia=0; $ia <= $#atom_symbols; $ia++){
#            foreach my $i (@basorder){
#                for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
#                    $pk=${$prim_index2{$i}}[$k];
#                      if($lcao_atomidx[$pk] == ($ia+1)){
#                         printf NEWFILE $lcao_format, ${$lcao[$j]}[$pk];
#                      }
#               }
#            }
#        }
#        if ($j==0) {
#         printf  NEWFILE " ((coef(ibasis,iorb),ibasis=1,nbasis),iorb=1,norb)\n";
#        } else {
#         printf  NEWFILE "\n";
#        }
#   }
###################################################################################
    my @final_lcao_coef=();
    foreach my $j (@orbital_indices){
	my @temp_lcao_coef=();
        for(my $ia=0; $ia <= $#atom_symbols; $ia++){
            foreach my $i (@basorder){
                for(my $k=0; $k<=$#{$prim_index2{$i}}; $k++){
                    $pk=${$prim_index2{$i}}[$k];
                      if($lcao_atomidx[$pk] == ($ia+1)){
			  my $temp_lcao_coef=sprintf "% .8E", ${$lcao[$j]}[$pk];
			  push @temp_lcao_coef, $temp_lcao_coef;
                      }
               }
            }
        }
	push @final_lcao_coef, [@temp_lcao_coef];
    }

    my @which_basis_used=();
    my $reduced_nbasis=0;
    if ($ispher == 1) {
	print "Removing redundant basis functions\n";
	my $tolerance = 10e-06;
	for my $current_basis (0..$nbasis-1) {
	    $current_basis_used=0;
	    for my $current_orb (@orbital_indices) {
		$current_basis_used = 1 if abs(${$final_lcao_coef[$current_orb]}[$current_basis]) > $tolerance;
	    }
	    push @which_basis_used, $current_basis if $current_basis_used;
	}

	for my $current_orb (@orbital_indices) {
	    @{$final_lcao_coef[$current_orb]} = @{$final_lcao_coef[$current_orb]}[@which_basis_used]; 
	}
	$reduced_nbasis = @{$final_lcao_coef[0]};
    }
    push @{$final_lcao_coef[0]}, "((coef(ibasis,iorb),ibasis=1,nbasis),iorb=1,norb)";
    print NEWFILE " @{$_}\n" for @final_lcao_coef;


###################################################################################
    printf NEWFILE " end\n";

     # print orbital eigenvalues
     printf NEWFILE " energies\n";
     for($i=0; $i<$porb; $i++){
      printf NEWFILE "$orbital_eigenvalues[@orbital_indices[$i]] ";
     }
     printf NEWFILE "\n end\n";

     # print symmetry info
     printf NEWFILE " symmetry\n";

     if($#irrep_strings > -1){
        %irreps=();
        $irrep_num=0;
        @irrep_index=();
        for($j=0; $j<$orbitals;$j++){
            if( ! exists $irreps{$irrep_strings[$j]}){
                $irrep_num++;
                $irreps{$irrep_strings[$j]}=$irrep_num;
                $idx=$irrep_num;
            } else {
                $idx=$irreps{$irrep_strings[$j]};
            }
            $irrep_index[$j]=$idx;
        }
            foreach my $j (@orbital_indices){
#JT                printf NEWFILE "%d ",$irrep_index[$j];
                printf NEWFILE "%s ",$irrep_strings[$j];  #JT print label of irrep instead of index
            }
    }

       printf NEWFILE "\n end\n";

     printf NEWFILE "end\n\n";
         

#   foreach my $j (@orbital_indices){
#   for($j=0; $j<$nbasis; $j++){
#JT      printf NEWFILE "1. ";
#      print "ftype[
#      printf NEWFILE "$exponents_slater[$j] ";  #JT
#      printf NEWFILE "%2.1f ",$irrep_index[$j];
#   }


# csfs menu
    printf NEWFILE "csfs\n";
    printf NEWFILE " determinants";

    # print unique determinants
    if ($detread) {

      for($i=1; $i<=$selected_det; $i++){
        printf NEWFILE "\n";
        @ocsym=split '',$sorted_detlist[$kept_det[$i]];
        for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '+') || ($ocsym[$j] eq '2')){
                if($omit_unused_orbitals){
                    printf NEWFILE "%3d ",$orb_index{$j}+1;
                } else {
                    printf NEWFILE "%3d ",$j+1;
                }
            }
        }
        printf NEWFILE  "    ";
        for($j=0; $j<=$#ocsym; $j++){
            if( ($ocsym[$j] eq '-') || ($ocsym[$j] eq '2')){
                if($omit_unused_orbitals){
                    printf NEWFILE "%3d ",$orb_index{$j}+1;
                } else {
                    printf NEWFILE "%3d ",$j+1;
                }
            }
        }
      }

    } else {

        printf NEWFILE  "\n";
        for($j=0; $j<$nalpha; $j++){
           printf NEWFILE "%d ",$j+1;
        }
        printf NEWFILE " ";
        for($j=0; $j<$nbeta; $j++){
           printf NEWFILE "%d ",$j+1;
        }
    }
    printf NEWFILE "(iworbd(j,idet),j=1,nelec)\n";

    printf NEWFILE " end\n";

   # print CSFs
   if ($detread) {

      printf NEWFILE " csf_coef ";

      # print csf_coef
      for($i=1; $i<=$ncsf; $i++){
        printf NEWFILE "%s ",@csf_coef[$i]
      }
      printf NEWFILE " end\n";

      printf NEWFILE " dets_in_csfs\n";

      # print csf
      for($i=1; $i<=$ncsf; $i++){

        # print dets
        foreach $d (@{$csf_trial[$i]}){
          $cdet=$$d{det};
          for($j=1; $j<=$selected_det; $j++){
            if ($kept_det[$j]==$cdet) {
               $kdet=$j;
            }
          }
          printf NEWFILE "%2d ",$kdet;
        }
        printf NEWFILE "\n";

        # print coefs
        foreach $d (@{$csf_trial[$i]}){

          printf NEWFILE "%s ",$$d{coef}*$phase_factors[$$d{det}]*$qmc_phase[$$d{det}];
        }
        printf NEWFILE "\n";

      }
      printf NEWFILE " end\n";

    }

   printf NEWFILE "end\n\n";

# Jastrow menu

   printf NEWFILE "jastrow\n";
   $norda=5;
   $nordb=5;
   $nordc=5;
   printf NEWFILE " ijas=4 isc=4\n";
   printf NEWFILE " scalek=0.8\n";

   printf NEWFILE " parameters\n";

   for($j=0; $j<$nctype; $j++){
    printf NEWFILE "0. 0. 0. 0. 0. 0. (a(iparmj),iparmj=1,nparma)\n";
   }
   if($no_jastrow){
    printf NEWFILE "0. 0. 0. 0. 0. 0. (b(iparmj),iparmj=1,nparmb)\n";
   }else{
    printf NEWFILE "0.5 1. 0. 0. 0. 0. (b(iparmj),iparmj=1,nparmb)\n";
   }
   for($j=0; $j<$nctype; $j++){
    printf NEWFILE "0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. (c(iparmj),iparmj=1,nparmc)\n";
   }
   printf NEWFILE " end\n";
   printf NEWFILE "end\n\n";

# optimization menu

    printf NEWFILE "optimization\n";
    printf NEWFILE " parameters jastrow end\n";
    printf NEWFILE " method = linear\n";
    printf NEWFILE "end\n";
    printf NEWFILE "\n";


   close(NEWFILE);
   printf ("New format input file written to $new_input_file\n") if(! $quiet);
   if($ecp){
   printf ("  Warning: verify values of lpotp1 especially for H ECP \n") if(! $quiet);
   }

}

###############################################################
sub print_orbital_eigenvalues{
###############################################################
# print orbital eigenvalues
# J. Toulouse - 11 Oct 2005
###############################################################

my $i;

 print "\n";

# number of printed orbitals
 print "$porb norb \n";

# print orbital eigenvalues
for($i=0; $i<$porb; $i++){
 print "$orbital_eigenvalues[@orbital_indices[$i]] ";
}

 print "(eigenvalues(ieig),ieig=1,norb)\n";

}

###############################################################
sub print_orb{
###############################################################
# print orbital file
# J. Toulouse - 01 Jan 2006
###############################################################
    open(ORBFILE,"> $orb_file") || die  "cant open file $orb_file : $!";

my $i;

 print "\n";

 printf ORBFILE "orbitals\n";

# print orbital eigenvalues
 printf ORBFILE " energies\n";
 for($i=0; $i<$porb; $i++){
  printf ORBFILE "$orbital_eigenvalues[@orbital_indices[$i]] ";
 }
 printf ORBFILE "\n end\n";

# print symmetry info
 printf ORBFILE " symmetry\n";

# irrep info
    if($#irrep_strings > -1){
	%irreps=();
	$irrep_num=0;
	@irrep_index=();
	for($j=0; $j<$orbitals;$j++){
	    if( ! exists $irreps{$irrep_strings[$j]}){
		$irrep_num++;
		$irreps{$irrep_strings[$j]}=$irrep_num;
		$idx=$irrep_num;
	    } else {
		$idx=$irreps{$irrep_strings[$j]};
	    }
	    $irrep_index[$j]=$idx;
	}
	    foreach my $j (@orbital_indices){
		printf ORBFILE "%d ",$irrep_index[$j];
	    }
    }

 printf ORBFILE "\n end\n";

 printf ORBFILE "end\n";

 printf ("Writing orbital info to $orb_file\n")  if(! $quiet);

 close(ORBFILE);
}

###############################################################
sub process_basis_function_type{
###############################################################
# check if the current basis function is a Gaussian function (S,P,D,F...)
# or a Slater function (1S,2S,2P,...)
#
# Count the numbers of Slater function of each kind (1S, 2S, 2P,...) and
# drop principal quantum number (1S -> S, 2S ->S, 2P -> P, ...)
#
# J. Toulouse - 15 Sep 2005
# WAS - bug fix for multiple atom basis sets  - July 1, 2007
###############################################################

    my $here="process_basis_function_type";

    #WAS fix the problem when more than one atom type exists
    my $atomtype=$_[0];
    if (!(defined ($defined_basis{$atomtype})))
    {
	$defined_basis{$atomtype}=1;
	$n1s{$atomtype} =0;	$n2s{$atomtype} =0;
	$n3s{$atomtype} =0;	$n4s{$atomtype} =0;$n5s{$atomtype} =0;
	$n2p{$atomtype} =0;
	$n3p{$atomtype} =0;	$n4p{$atomtype} =0;$n5p{$atomtype} =0;
	$n3d{$atomtype} =0;	$n4d{$atomtype} =0;$n5d{$atomtype} =0;
	$n3f{$atomtype} =0;	$n4f{$atomtype} =0;$n5f{$atomtype} =0;
	$n3g{$atomtype} =0;	$n4g{$atomtype} =0;$n5g{$atomtype} =0;
    }
    ### WAS

    $is_slater_function =  0;

# Gaussians
    if($ftype[$current_func] eq "S"){
	if($is_new_function){
	    $n1s{$atomtype} = $n1s{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "P"){
	if($is_new_function){
	    $n2p{$atomtype} = $n2p{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "D"){
	if($is_new_function){
	    $n3d{$atomtype} = $n3d{$atomtype} + 1;
	    if (! $ispher) {
		$n3s{$atomtype} = $n3s{$atomtype} + 1;   # 6d ->5d,s
	    }
	}
    }
    elsif($ftype[$current_func] eq "F"){
	if($is_new_function){
	    $n4f{$atomtype} = $n4f{$atomtype} + 1;
	    if (! $ispher) {	 
		$n4p{$atomtype} = $n4p{$atomtype} + 1;  # 10f ->7f,3p
	    }
	}
    }
    elsif($ftype[$current_func] eq "G"){
	if($is_new_function){
	    $n5g{$atomtype} = $n5g{$atomtype} + 1;
	    if (! $ispher) {
		$n5d{$atomtype} = $n5d{$atomtype} + 1;  # 15g ->9g,5d,1s
		$n5s{$atomtype} = $n5s{$atomtype} + 1;  # 15g ->9g,5d,1s
	    }
	}
    }
    elsif($ftype[$current_func] eq "L"){}


#Gauss-Slaters
# Gaussians
    elsif($ftype[$current_func] eq "GS-S"){
	$ftype[$current_func] = 'S';
	if($is_new_function){
	    $n1s{$atomtype} = $n1s{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "GS-P"){
	$ftype[$current_func] = 'P';
	if($is_new_function){
	    $n2p{$atomtype} = $n2p{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "GS-D"){
	$ftype[$current_func] = 'D';
	if($is_new_function){
	    $n3d{$atomtype} = $n3d{$atomtype} + 1;
	    if (! $ispher) {
		$n3s{$atomtype} = $n3s{$atomtype} + 1;   # 6d ->5d,s
	    }
	}
    }
    elsif($ftype[$current_func] eq "GS-F"){
	$ftype[$current_func] = 'F';
	if($is_new_function){
	    $n4f{$atomtype} = $n4f{$atomtype} + 1;
	    if (! $ispher) {	 
		$n4p{$atomtype} = $n4p{$atomtype} + 1;  # 10f ->7f,3p
	    }
	}
    }
    elsif($ftype[$current_func] eq "GS-G"){
	$ftype[$current_func] = 'G';
	if($is_new_function){
	    $n5g{$atomtype} = $n5g{$atomtype} + 1;
	    if (! $ispher) {
		$n5d{$atomtype} = $n5d{$atomtype} + 1;  # 15g ->9g,5d,1s
		$n5s{$atomtype} = $n5s{$atomtype} + 1;  # 15g ->9g,5d,1s
	    }
	}
    }



# Slaters
    elsif($ftype[$current_func] eq "1S"){
	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'S';
	$function_slater_quantum_number[$current_func] = '1';
	if($is_new_function){
	    $n1s{$atomtype} = $n1s{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "2S"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'S';
	$function_slater_quantum_number[$current_func] = '2';
	if($is_new_function){
	    $n2s{$atomtype} = $n2s{$atomtype} + 1;
	}

    }
    elsif($ftype[$current_func] eq "3S"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'S';
	$function_slater_quantum_number[$current_func] = '3';
	if($is_new_function){
	    $n3s{$atomtype} = $n3s{$atomtype} + 1;
	}

    }
    elsif($ftype[$current_func] eq "4S"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'S';
	$function_slater_quantum_number[$current_func] = '4';
	if($is_new_function){
	    $n4s{$atomtype} = $n4s{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "5S"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'S';
	$function_slater_quantum_number[$current_func] = '5';
	if($is_new_function){
	    $n5s{$atomtype} = $n5s{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "2P"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'P';
	$function_slater_quantum_number[$current_func] = '2';
	if($is_new_function){
	    $n2p{$atomtype} = $n2p{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "3P"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'P';
	$function_slater_quantum_number[$current_func] = '3';
	if($is_new_function){
	    $n3p{$atomtype} = $n3p{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "4P"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'P';
	$function_slater_quantum_number[$current_func] = '4';
	if($is_new_function){
	    $n4p{$atomtype} = $n4p{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "5P"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'P';
	$function_slater_quantum_number[$current_func] = '5';
	if($is_new_function){
	    $n5p{$atomtype} = $n5p{$atomtype} + 1;
	}
    }
    elsif($ftype[$current_func] eq "3D"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'D';
	$function_slater_quantum_number[$current_func] = '3';
	if($is_new_function){
	    $n3d{$atomtype} = $n3d{$atomtype} + 1;
	    if (! $ispher) {
		$n3s{$atomtype} = $n3s{$atomtype} + 1;   # 6d ->5d,s
	    }
	}
    }
    elsif($ftype[$current_func] eq "4D"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'D';
	$function_slater_quantum_number[$current_func] = '4';
	if($is_new_function){
	    $n4d{$atomtype} = $n4d{$atomtype} + 1;
	    if (! $ispher) {
		$n4s{$atomtype} = $n4s{$atomtype} + 1;  # 6d ->5d,s
	    }
	}
    }
    elsif($ftype[$current_func] eq "5D"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'D';
	$function_slater_quantum_number[$current_func] = '5';
	if($is_new_function){
	    $n5d{$atomtype} = $n5d{$atomtype} + 1;
	    if (! $ispher) {
		$n5s{$atomtype} = $n5s{$atomtype} + 1;  # 6d ->5d,s
	    }
	}
    }
    elsif($ftype[$current_func] eq "4F"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'F';
	$function_slater_quantum_number[$current_func] = '4';
	if($is_new_function){
	    $n4f{$atomtype} = $n4f{$atomtype} + 1;
	    if (! $ispher) {
		$n4p{$atomtype} = $n4p{$atomtype} + 1;  # 10f ->7f,3p
	    }
	}
    }
    elsif($ftype[$current_func] eq "5F"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'F';
	$function_slater_quantum_number[$current_func] = '5';
	if($is_new_function){
	    $n5f{$atomtype} = $n5f{$atomtype} + 1;
	    if (! $ispher) {
		$n5p{$atomtype} = $n5p{$atomtype} + 1;  # 10f ->7f,3p
	    }
	}
    }
    elsif($ftype[$current_func] eq "5G"){

	$is_slater_function = 1;
	$function_slater_type[$current_func] = $ftype[$current_func];
	$ftype[$current_func] = 'G';
	$function_slater_quantum_number[$current_func] = '5';
	if($is_new_function){
	    $n5g{$atomtype} = $n5g{$atomtype} + 1;
	    if (! $ispher) {
		$n5d{$atomtype} = $n5d{$atomtype} + 1;  # 15g ->9g,5d,1s
		$n5s{$atomtype} = $n5s{$atomtype} + 1;  # 15g ->9g,5d,1s
	    }
	}
    }
    else{
	print "$here: unknow basis function type: $ftype[$current_func]\n";
	exit;
    }
}


###############################################################
sub check_slater_functions_order{
###############################################################
# Check correct order of Slater functions.
# 1S < 2S < 3S < 4S < ...
# 2P < 3P < 4P < ...
#
# J. Toulouse - 15 Sep 2005
###############################################################

  my $here = "check_slater_functions_order";

# Loop over all atoms
  for($a=0; $a <= $#atom_symbols; $a++){


# Loop over shells (S, P, D, F, G)
  for($s=0; $s <= $#shells; $s++){

  $current_quantum_number_previous = 0;

   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
     $current_func_slater_type = $function_slater_type[$current_func_index];

   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq $shells[$s]){

    $current_quantum_number = $function_slater_quantum_number[$current_func_index];

    if($current_quantum_number_previous > $current_quantum_number){
     print "\n$here: ERROR\n";
     print "$here: Wrong ordering of Slater basis functions\n";
     print "$here: A function $current_func_slater_type_previous has been found before a function $current_func_slater_type\n";
     exit;
    }

    $current_quantum_number_previous = $current_quantum_number;
    $current_func_slater_type_previous = $current_func_slater_type;

   }

   }

 } # end loop over shells

 } # end loop over atoms

}

###############################################################
sub process_slater_exponents{
###############################################################
# Construct the total list of Slater exponents in correct order
#
# J. Toulouse - 15 Sep 2005
###############################################################

  my $here = "process_slater_exponents";

# Loop over all atoms
  for($a=0; $a <= $#atom_symbols; $a++){

# Exponents for S
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'S'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }

   # 6d ->5d,s
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'D'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }
   # 15g ->9g,5d,1s
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'G'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }
   }

# Exponents for P
   for($i=0; $i < 3; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'P'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }

   # 10f ->7f,3p
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'F'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }

   }
   }

# Exponents for D
   for($i=0; $i < 5; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'D'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }

#  15g -> 9g,5d,1s
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'G'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }

   }
   }

# Exponents for F
   for($i=0; $i < 7; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'F'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }
   }
   }

# Exponents for G
   for($i=0; $i < 9; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_symbols[$a] && $ftype[$current_func_index] eq 'G'){
    push @exponents_slater_ordered,$exponents_slater[$function_type_index[$j]];
   }
   }
   }

 } # end loop over atoms

# print "nbasis=$nbasis\n";

 $exponents_slater_ordered_nb = $#exponents_slater_ordered +1;

 if( $exponents_slater_ordered_nb != $nbasis){
  print "$here: ERROR\n";
  print "$here: number of processed Slater exponents: $exponents_slater_ordered_nb\n";
  print "$here: number of basis functions: $nbasis\n";
  print "$here: they should be equal.\n";
  exit;
 }

}
###############################################################
sub process_slater_exponents_by_atom_type{
###############################################################
# Construct the list of Slater exponents in correct order
# BY ATOM TYPE
#
# J. Toulouse - 25 Apr 2009
###############################################################

  my $here = "process_slater_exponents_by_atom_type";


# Loop over all atom types
  foreach my $a (@atom_types){
   
# Exponents for S
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'S'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }

   if (! $ispher) {
   # 6d ->5d,s
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'D'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }
   # 15g ->9g,5d,1s
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'G'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }
   }
   }

# Exponents for P
   for($i=0; $i < 3; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'P'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }

   if (! $ispher) {
   # 10f ->7f,3p
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'F'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }
   }
   }
   }

# Exponents for D
   for($i=0; $i < 5; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'D'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }

   if (! $ispher) {
#  15g -> 9g,5d,1s
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'G'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }
   }
   }
   }

# Exponents for F
   for($i=0; $i < 7; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'F'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }
   }
   }

# Exponents for G
   for($i=0; $i < 9; $i++){
   for($j=0; $j <= $#function_type_index ; $j++){
     $current_func_index = $function_type_index[$j];
     $current_func_symbol = $function_type_symbol[$j];
   if($current_func_symbol eq $atom_types[$atom_type_index{$a}] && $ftype[$current_func_index] eq 'G'){
    push @{$exponents_slater_ordered_by_atom_type{$a}},$exponents_slater[$function_type_index[$j]];
   }
   }
   }

#    printf "exponents_slater_ordered_by_atom_type=@{$exponents_slater_ordered_by_atom_type{$a}}\n";
#    printf "exponents_slater_ordered_by_atom_type=${$exponents_slater_ordered_by_atom_type{$a}}[0]\n";
#    printf "exponents_slater_ordered_by_atom_type=${$exponents_slater_ordered_by_atom_type{$a}}[1]\n";
 } # end loop over atoms


}
###############################################################
sub process_basis_functions_by_atom_type{
###############################################################
# Construct the list of basis functions in correct order
# BY ATOM TYPE
#
# J. Toulouse - 25 Apr 2009
###############################################################

    foreach my $a (@atom_types){
        @c=();
        @r=();
        basis_info_cyrus($a,\@c,\@r);
#        printf "\n %d \n",$atom_type_index{$a}+1;
#        if($analytic_basis){ #needs to use always n, even for Gaussians of Gauss-Slater because of cartesian -> spherical
        for(my $i=1; $i<= $n1s{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "1S";}
        for(my $i=1; $i<= $n2s{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "2S";}
        for(my $i=1; $i<= $n3s{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3S";}
        for(my $i=1; $i<= $n4s{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4S";}
        for(my $i=1; $i<= $n5s{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5S";}
        for(my $i=1; $i<= $n2p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "2PX";}
        for(my $i=1; $i<= $n3p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3PX";}
        for(my $i=1; $i<= $n4p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4PX";}
        for(my $i=1; $i<= $n5p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5PX";}
        for(my $i=1; $i<= $n2p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "2PY";}
        for(my $i=1; $i<= $n3p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3PY";}
        for(my $i=1; $i<= $n4p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4PY";}
        for(my $i=1; $i<= $n5p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5PY";}
        for(my $i=1; $i<= $n2p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "2PZ";}
        for(my $i=1; $i<= $n3p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3PZ";}
        for(my $i=1; $i<= $n4p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4PZ";}
        for(my $i=1; $i<= $n5p{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5PZ";}
        for(my $i=1; $i<= $n3d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3D0";}
        for(my $i=1; $i<= $n4d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4D0";}
        for(my $i=1; $i<= $n3d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3D+2";}
        for(my $i=1; $i<= $n4d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4D+2";}
        for(my $i=1; $i<= $n5d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5D+2";}
        for(my $i=1; $i<= $n3d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3D-2";}
        for(my $i=1; $i<= $n4d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4D-2";}
        for(my $i=1; $i<= $n5d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5D-2";}
        for(my $i=1; $i<= $n3d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3D+1";}
        for(my $i=1; $i<= $n4d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4D+1";}
        for(my $i=1; $i<= $n5d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5D+1";}
        for(my $i=1; $i<= $n3d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "3D-1";}
        for(my $i=1; $i<= $n4d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4D-1";}
        for(my $i=1; $i<= $n5d{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5D-1";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F+3";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F+3";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F-3";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F-3";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F+2";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F+2";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F-2";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F-2";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F+1";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F+1";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F-1";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F-1";}
        for(my $i=1; $i<= $n4f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "4F0";}
        for(my $i=1; $i<= $n5f{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5F0";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G+4";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G-4";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G+3";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G-3";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G+2";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G-2";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G+1";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G-1";}
        for(my $i=1; $i<= $n5g{$a}; $i++){push @{$basis_functions_by_atom_type{$a}}, "5G0";}
#        printf "basis_functions_by_atom_type=@{$basis_functions_by_atom_type{$a}}\n";
#        }
#        else{
#        for(my $i=1; $i<= $c[0]; $i++){push @{$basis_functions_by_atom_type{$a}}, "S";}
#        for(my $i=1; $i<= $c[1]; $i++){push @{$basis_functions_by_atom_type{$a}}, "PX";}
#        for(my $i=1; $i<= $c[2]; $i++){push @{$basis_functions_by_atom_type{$a}}, "PY";}
#        for(my $i=1; $i<= $c[3]; $i++){push @{$basis_functions_by_atom_type{$a}}, "PZ";}
#        for(my $i=1; $i<= $c[4]; $i++){push @{$basis_functions_by_atom_type{$a}}, "D0";}
#        for(my $i=1; $i<= $c[5]; $i++){push @{$basis_functions_by_atom_type{$a}}, "D+2";}
#        for(my $i=1; $i<= $c[6]; $i++){push @{$basis_functions_by_atom_type{$a}}, "D-2";}
#        for(my $i=1; $i<= $c[7]; $i++){push @{$basis_functions_by_atom_type{$a}}, "D+1";}
#        for(my $i=1; $i<= $c[8]; $i++){push @{$basis_functions_by_atom_type{$a}}, "D-1";}
#        for(my $i=1; $i<= $c[9]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F+3";}
#        for(my $i=1; $i<= $c[10]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F-3";}
#        for(my $i=1; $i<= $c[11]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F+2";}
#        for(my $i=1; $i<= $c[12]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F-2";}
#        for(my $i=1; $i<= $c[13]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F+1";}
#        for(my $i=1; $i<= $c[14]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F-1";}
#        for(my $i=1; $i<= $c[15]; $i++){push @{$basis_functions_by_atom_type{$a}}, "F0";}
#        for(my $i=1; $i<= $c[16]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G+4";}
#        for(my $i=1; $i<= $c[17]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G-4";}
#        for(my $i=1; $i<= $c[18]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G+3";}
#        for(my $i=1; $i<= $c[19]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G-3";}
#        for(my $i=1; $i<= $c[20]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G+2";}
#        for(my $i=1; $i<= $c[21]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G-2";}
#        for(my $i=1; $i<= $c[22]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G+1";}
#        for(my $i=1; $i<= $c[23]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G-1";}
#        for(my $i=1; $i<= $c[24]; $i++){push @{$basis_functions_by_atom_type{$a}}, "G0";}
#        for(my $i=1; $i<= $c[25]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H+5";}
#        for(my $i=1; $i<= $c[26]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H-5";}
#        for(my $i=1; $i<= $c[27]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H+4";}
#        for(my $i=1; $i<= $c[28]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H-4";}
#        for(my $i=1; $i<= $c[29]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H+3";}
#        for(my $i=1; $i<= $c[30]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H-3";}
#        for(my $i=1; $i<= $c[31]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H+2";}
#        for(my $i=1; $i<= $c[32]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H-2";}
#        for(my $i=1; $i<= $c[33]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H+1";}
#        for(my $i=1; $i<= $c[34]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H-1";}
#        for(my $i=1; $i<= $c[35]; $i++){push @{$basis_functions_by_atom_type{$a}}, "H0";}
##        printf "basis_functions_by_atom_type=@{$basis_functions_by_atom_type{$a}}\n";
#        }

   }
}
###############################################################
sub check_for_symmetry_in_orbitals{
###############################################################
# check and impose additional symmetry on the orbitals
#
# For homonuclear diatomic molecules in D4h symmetry, EU -> EUX,EUY and EG -> EGX,EGY
# For heteronuclear diatomic molecules in C4h symmetry, E -> EX,EY
#
# J. Toulouse - 31 Jan 2007
###############################################################

  my $here = "check_for_symmetry_in_orbitals";

  print "\n";

# Loop over all orbitals
  for($i=0; $i < $orbitals; $i++){
#   print "$here: orbital # $i symmetry $irrep_strings[$i]\n";

#  Resolve X and Y components of EU symmetry
   if ($irrep_strings[$i] eq 'EU'){

    $symmetry_is_EUX=1;
    $symmetry_is_EUY=1;

#   Loop over basis functions
#    print "$here: coefficients: ";
    for($k=0; $k < $nbasis; $k++){

#     print "\n$lcao_bflabel[$k] ${$lcao[$i]}[$k]\n";

#     if ($lcao_bflabel[$k] == 'X' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EUX=0;}
#     if ($lcao_bflabel[$k] == 'XZ' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EUX=0;}
#     if ($lcao_bflabel[$k] == 'Y' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EUY=0;}
#     if ($lcao_bflabel[$k] == 'YZ' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EUY=0;}

     if ($lcao_bflabel[$k] eq 'X' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EUY=0;}
     if ($lcao_bflabel[$k] eq 'XZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EUY=0;}
     if ($lcao_bflabel[$k] eq 'Y' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EUX=0;}
     if ($lcao_bflabel[$k] eq 'YZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EUX=0;}

    }

#    print "symmetry_is_EUX=$symmetry_is_EUX symmetry_is_EUY=$symmetry_is_EUY\n";
    if ($symmetry_is_EUX == 1 && $symmetry_is_EUY == 0){$irrep_strings[$i]='EUX';}
    if ($symmetry_is_EUX == 0 && $symmetry_is_EUY == 1){$irrep_strings[$i]='EUY';}

   } # end symmetry EU

#  Resolve X and Y components of EG symmetry
   if ($irrep_strings[$i] eq 'EG'){

    $symmetry_is_EGX=1;
    $symmetry_is_EGY=1;

#   Loop over basis functions
#    print "$here: coefficients: ";
    for($k=0; $k < $nbasis; $k++){

#     print "\n$lcao_bflabel[$k] ${$lcao[$i]}[$k]\n";

#     if ($lcao_bflabel[$k] == 'X' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EGX=0;}
#     if ($lcao_bflabel[$k] == 'XZ' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EGX=0;}
#     if ($lcao_bflabel[$k] == 'Y' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EGY=0;}
#     if ($lcao_bflabel[$k] == 'YZ' && ${$lcao[$i]}[$k] == 0){$symmetry_is_EGY=0;}

     if ($lcao_bflabel[$k] eq 'X' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EGY=0;}
     if ($lcao_bflabel[$k] eq 'XZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EGY=0;}
     if ($lcao_bflabel[$k] eq 'Y' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EGX=0;}
     if ($lcao_bflabel[$k] eq 'YZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EGX=0;}

    }

#    print "symmetry_is_EGX=$symmetry_is_EGX symmetry_is_EGY=$symmetry_is_EGY\n";
    if ($symmetry_is_EGX == 1 && $symmetry_is_EGY == 0){$irrep_strings[$i]='EGX';}
    if ($symmetry_is_EGX == 0 && $symmetry_is_EGY == 1){$irrep_strings[$i]='EGY';}

   } # end symmetry EG


#  Resolve X and Y components of E symmetry
   if ($irrep_strings[$i] eq 'E'){

    $symmetry_is_EX=1;
    $symmetry_is_EY=1;

#   Loop over basis functions
#    print "$here: coefficients: ";
    for($k=0; $k < $nbasis; $k++){

#     print "\n$lcao_bflabel[$k] ${$lcao[$i]}[$k]\n";

     if ($lcao_bflabel[$k] eq 'X' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EY=0;}
     if ($lcao_bflabel[$k] eq 'XZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EY=0;}
     if ($lcao_bflabel[$k] eq 'Y' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EX=0;}
     if ($lcao_bflabel[$k] eq 'YZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_EX=0;}

    }

#    print "symmetry_is_EX=$symmetry_is_EX symmetry_is_EY=$symmetry_is_EY\n";
    if ($symmetry_is_EX == 1 && $symmetry_is_EY == 0){$irrep_strings[$i]='EX';}
    if ($symmetry_is_EX == 0 && $symmetry_is_EY == 1){$irrep_strings[$i]='EY';}

   } # end symmetry E

#  Resolve X and Y components of B1 symmetry in C2V group
   if ($irrep_strings[$i] eq 'B1'){

    $symmetry_is_B1X=1;
    $symmetry_is_B1Y=1;

#   Loop over basis functions
#    print "$here: coefficients: ";
    for($k=0; $k < $nbasis; $k++){

#     print "\n$lcao_bflabel[$k] ${$lcao[$i]}[$k]\n";

     if ($lcao_bflabel[$k] eq 'X' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B1Y=0;}
     if ($lcao_bflabel[$k] eq 'XZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B1Y=0;}
     if ($lcao_bflabel[$k] eq 'Y' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B1X=0;}
     if ($lcao_bflabel[$k] eq 'YZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B1X=0;}

    }

#    print "symmetry_is_B1X=$symmetry_is_B1X symmetry_is_B1Y=$symmetry_is_B1Y\n";
    if ($symmetry_is_B1X == 1 && $symmetry_is_B1Y == 0){$irrep_strings[$i]='B1X';}
    if ($symmetry_is_B1X == 0 && $symmetry_is_B1Y == 1){$irrep_strings[$i]='B1Y';}

   } # end symmetry B1

#  Resolve X and Y components of B2 symmetry in C2V group
   if ($irrep_strings[$i] eq 'B2'){

    $symmetry_is_B2X=1;
    $symmetry_is_B2Y=1;

#   Loop over basis functions
#    print "$here: coefficients: ";
    for($k=0; $k < $nbasis; $k++){

#     print "\n$lcao_bflabel[$k] ${$lcao[$i]}[$k]\n";

     if ($lcao_bflabel[$k] eq 'X' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B2Y=0;}
     if ($lcao_bflabel[$k] eq 'XZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B2Y=0;}
     if ($lcao_bflabel[$k] eq 'Y' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B2X=0;}
     if ($lcao_bflabel[$k] eq 'YZ' && ${$lcao[$i]}[$k] != 0){$symmetry_is_B2X=0;}

    }

#    print "symmetry_is_B2X=$symmetry_is_B2X symmetry_is_B2Y=$symmetry_is_B2Y\n";
    if ($symmetry_is_B2X == 1 && $symmetry_is_B2Y == 0){$irrep_strings[$i]='B2X';}
    if ($symmetry_is_B2X == 0 && $symmetry_is_B2Y == 1){$irrep_strings[$i]='B2Y';}

   } # end symmetry B2

  }

}
###############################################################
sub print_usage{
###############################################################
# tell how to use this program using the text after __DATA__
###############################################################

    while(<DATA>){
	print $_;
    }

    print "\n --- Orbital Types ---\n";
    foreach my $i (keys(%orbid)){
	printf "%20s : %s\n",$i,$orbnames[$orbid{$i}];
    }

    print_usage_summary();

    exit;

}

###############################################################
sub print_usage_summary{
###############################################################
# display usage summary
# J. Toulouse - 11 Oct 2005
###############################################################

print "---------------------------------------------------\n";
print "Usage summary:\n";
print "\n";

print "Umrigar format:\n";
print "To get first 9 orbitals:\n";
print "HF run:  gamess2qmc -C -t rhf -n 9 gamess_output:\n";
print "CI run:  gamess2qmc -C -F -t initial -n 9 -d 0.1 gamess_output:\n";
print "or to get used orbitals (in GUGA only):\n";
print "CI run:  gamess2qmc -C -F -t initial -u -d 0.1 gamess_output\n";
print "The 0.1 says keep determinants with a coef. of 0.1 and larger\n";
print "The -F generates a separate .csf file that contains the coefs of dets (in\n";
print "addition to the csf coefs.  The former can be used to figure out how many\n";
print "independent CSFs there really are in those cases where the molecule has a\n";
print "higher point group symmetry than d4h symmetry (the highest symmetry in GAMESS)\n";

}

###############################################################
# Finally : run main routine
main();
###############################################################

###############################################################
# the rest is data and printed  be the usage-routine
# exactly the way it is written below.
__DATA__

gamess2qmc: conversion of geometry, basis, orbitals (lcao), and CI-information
            from  GAMESS(US) output to formats suitable for QMC and EFPCI.

usage: gamess2qmc [OPTIONS]  gamess_output
       OPTIONS:

           -g              create geometry file
           -r              create basis on radial grid files
           -s              create file with lcao symmetry information
           -t type         fetch orbitals of specified type and create lcao file
           -n norb         fetch first norb orbitals instead of all
           -d threshold    select CSF's with abs(csf_coef) >= threshold in gamess2qmc
           -f threshold    select CSF's with abs(csf_coef) >= threshold in det2csf
	                   (used only in printout in gamess2qmc)
           -w state        select state for trial wave function (default 1)
           -u              omit unused orbitals

           -e              generate EFPCI input (all states, CSFs and determinants)
           -j n            case vector format (0 heuristic possibly not unique, 1 from gamess)
           -E              same as '-t initial -s -e -j 0' (i.e. all what is needed for EFPCI)
           -D              short for '-t initial -d 0.9 -w 1 -u'

           -b basename     alternative basename for output files
           -x file         source extended option file (e.g. different grid parameters)
           -l              re-read lcao coefficients (VEC format) from dat-file
                           (only available for orbital type initial)
           -c file         get lcao coefficients from 'lcao' file and transform back
                           to VEC format (i.e. qmc2gamess )

           -v n            set verbosity level to n
           -q              quiet (no print to stdout)
           -h              print this message
           -C              generates input file in Cyrus format.  Requires -t option.
                           For multi-determinants, should also use -d
           -N              generates also input file in new format
           -J              Julien's options
           -F              print CSF list to file
           -S              create input for analytic Slater basis set
           -a              create input with no jastrow
           -o output_file  specify output file name

  Output is written to various files with basename like GAMESS output or
  given with -b, extensions as follows:
  *.geometry  : molecular geometry
  *.basis.N   : radial grids for atom #N
  *.bfinfo    : pointers basis functions -> radial part
  *.lcao      : orbital coefficients
  *.sym       : orbital pointgroup symmetry information
  *.det       : determinantal expansion of trial state
  *.efpci     : CSFs, determinants and states for EFPCI
  *.i0        : QMC input file in Cyrus' format
  *.csf       : CSFs

  === Version  $Revision: 1.12 $ ===
